{"ast":null,"code":"/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n\n */\nvar util = require('util');\nvar events = require('events');\nvar fs = require('fs');\nvar async = require('async');\nvar split = require('./split.js');\nvar convert = require('./convert.js');\nvar pathHash = require('pathhash');\nvar ocr = require('./ocr.js');\nvar rimraf = require('rimraf');\nfunction Raw() {\n  if (false === this instanceof Raw) {\n    return new Raw();\n  }\n}\nutil.inherits(Raw, events.EventEmitter);\nmodule.exports = Raw;\n\n/**\n * @param {String} pdf_path path to the pdf file on disk\n * @param {Boolean} params.clean true to remove the temporary single-page pdf\n *   files from disk. Sometimes however you might want to be able to use those\n *   single page pdfs after the ocr completes. In this case pass clean = false\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nRaw.prototype.process = function (pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  if (!options) {\n    options = {};\n  }\n  // default to removing the single page pdfs after ocr completes\n  if (!options.hasOwnProperty('clean')) {\n    options.clean = true;\n  }\n  fs.exists(pdf_path, function (exists) {\n    if (!exists) {\n      var err = 'no file exists at the path you specified: ' + pdf_path;\n      self.emit('error', {\n        error: err,\n        pdf_path: pdf_path\n      });\n      return;\n    }\n    pathHash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', {\n          error: err,\n          pdf_path: pdf_path\n        });\n        return;\n      }\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n        if (!output) {\n          err = 'no files returned from split';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        split_output = output;\n        var pdf_files = output.files;\n        if (!pdf_files || pdf_files.length == 0) {\n          err = 'error, no pages where found in your pdf document';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n        var index = 0;\n        var num_pages = pdf_files.length;\n        var single_page_pdf_file_paths = [];\n        async.forEachSeries(pdf_files,\n        // extract the text for each page via ocr\n        function (pdf_file, cb) {\n          var quality = 300;\n          if (options.hasOwnProperty('quality') && options.quality) {\n            quality = options.quality;\n          }\n          convert(pdf_file.file_path, quality, function (err, tif_path) {\n            var zeroBasedNumPages = num_pages - 1;\n            self.emit('log', 'converted page to intermediate tiff file, page ' + index + ' (0-based indexing) of ' + zeroBasedNumPages);\n            if (err) {\n              return cb(err);\n            }\n            var ocr_flags = ['-psm 6'];\n            if (options.ocr_flags) {\n              ocr_flags = options.ocr_flags;\n            }\n            ocr(tif_path, ocr_flags, function (err, extract) {\n              fs.unlink(tif_path, function (tif_cleanup_err, reply) {\n                if (tif_cleanup_err) {\n                  err += ', error removing temporary tif file: \"' + tif_cleanup_err + '\"';\n                }\n                if (err) {\n                  return cb(err);\n                }\n                var page_number = index + 1;\n                self.emit('log', 'raw ocr: page ' + index + ' (0-based indexing) of ' + zeroBasedNumPages + ' complete');\n                single_page_pdf_file_paths.push(pdf_file.file_path);\n                self.emit('page', {\n                  hash: hash,\n                  text: extract,\n                  index: index,\n                  num_pages: num_pages,\n                  pdf_path: pdf_path,\n                  single_page_pdf_path: pdf_file.file_path\n                });\n                text_pages.push(extract);\n                index++;\n                cb();\n              });\n            });\n          });\n        }, function (err) {\n          if (err) {\n            self.emit('error', err);\n            return;\n          }\n          self.emit('complete', {\n            hash: hash,\n            text_pages: text_pages,\n            pdf_path: pdf_path,\n            single_page_pdf_file_paths: single_page_pdf_file_paths\n          });\n        });\n      });\n    });\n  });\n};","map":{"version":3,"names":["util","require","events","fs","async","split","convert","pathHash","ocr","rimraf","Raw","inherits","EventEmitter","module","exports","prototype","process","pdf_path","options","self","text_pages","split_output","hasOwnProperty","clean","exists","err","emit","error","hash","output","pdf_files","files","length","index","num_pages","single_page_pdf_file_paths","forEachSeries","pdf_file","cb","quality","file_path","tif_path","zeroBasedNumPages","ocr_flags","extract","unlink","tif_cleanup_err","reply","page_number","push","text","single_page_pdf_path"],"sources":["D:/LangChainJS/chatpdf/node_modules/pdf-extract/lib/raw.js"],"sourcesContent":["/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n\n */\nvar util = require('util');\nvar events = require('events');\nvar fs = require('fs');\nvar async = require('async');\nvar split = require('./split.js');\nvar convert = require('./convert.js');\nvar pathHash = require('pathhash');\nvar ocr = require('./ocr.js');\nvar rimraf = require('rimraf');\n\n\nfunction Raw(){\n  if(false === (this instanceof Raw)) {\n    return new Raw();\n  }\n}\nutil.inherits(Raw, events.EventEmitter);\nmodule.exports = Raw;\n\n\n/**\n * @param {String} pdf_path path to the pdf file on disk\n * @param {Boolean} params.clean true to remove the temporary single-page pdf\n *   files from disk. Sometimes however you might want to be able to use those\n *   single page pdfs after the ocr completes. In this case pass clean = false\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nRaw.prototype.process = function(pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  if (!options) {\n    options = {};\n  }\n  // default to removing the single page pdfs after ocr completes\n  if (!options.hasOwnProperty('clean')) {\n    options.clean = true;\n  }\n  fs.exists(pdf_path, function (exists) {\n    if (!exists) {\n      var err = 'no file exists at the path you specified: ' + pdf_path\n      self.emit('error', { error: err, pdf_path: pdf_path});\n      return\n    }\n    pathHash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', { error: err, pdf_path: pdf_path});\n        return;\n      }\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        if (!output) {\n          err = 'no files returned from split';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return;\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        split_output = output;\n        var pdf_files = output.files;\n        if (!pdf_files || pdf_files.length == 0) {\n          err = 'error, no pages where found in your pdf document';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return;\n        }\n        var index = 0;\n        var num_pages = pdf_files.length\n        var single_page_pdf_file_paths = [];\n        async.forEachSeries(\n          pdf_files,\n          // extract the text for each page via ocr\n          function (pdf_file, cb) {\n            var quality = 300;\n            if (options.hasOwnProperty('quality') && options.quality) {\n              quality = options.quality;\n            }\n            convert(pdf_file.file_path, quality, function (err, tif_path) {\n              var zeroBasedNumPages = num_pages-1;\n              self.emit('log', 'converted page to intermediate tiff file, page '+ index+ ' (0-based indexing) of '+ zeroBasedNumPages);\n              if (err) { return cb(err); }\n              var ocr_flags = [\n                '-psm 6'\n              ];\n              if (options.ocr_flags) {\n                ocr_flags = options.ocr_flags;\n              }\n              ocr(tif_path, ocr_flags, function (err, extract) {\n                fs.unlink(tif_path, function (tif_cleanup_err, reply) {\n                  if (tif_cleanup_err) {\n                    err += ', error removing temporary tif file: \"'+tif_cleanup_err+'\"';\n                  }\n                  if (err) { return cb(err); }\n                  var page_number = index+1\n                  self.emit('log', 'raw ocr: page ' + index + ' (0-based indexing) of ' +zeroBasedNumPages + ' complete');\n                  single_page_pdf_file_paths.push(pdf_file.file_path);\n                  self.emit('page', { hash: hash, text: extract, index: index, num_pages: num_pages, pdf_path: pdf_path, single_page_pdf_path: pdf_file.file_path});\n                  text_pages.push(extract);\n                  index++;\n                  cb();\n                });\n              });\n            });\n          }, function (err) {\n            if (err) {\n              self.emit('error', err);\n              return;\n            }\n            self.emit('complete', { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths});\n          });\n      });\n    });\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}