{"ast":null,"code":"import net from 'node:net';\nimport unhandler from './utils/unhandle.js';\nconst reentry = Symbol('reentry');\nconst noop = () => {};\nexport class TimeoutError extends Error {\n  constructor(threshold, event) {\n    super(`Timeout awaiting '${event}' for ${threshold}ms`);\n    Object.defineProperty(this, \"event\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: event\n    });\n    Object.defineProperty(this, \"code\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = 'TimeoutError';\n    this.code = 'ETIMEDOUT';\n  }\n}\nexport default function timedOut(request, delays, options) {\n  if (reentry in request) {\n    return noop;\n  }\n  request[reentry] = true;\n  const cancelers = [];\n  const {\n    once,\n    unhandleAll\n  } = unhandler();\n  const addTimeout = (delay, callback, event) => {\n    const timeout = setTimeout(callback, delay, delay, event);\n    timeout.unref?.();\n    const cancel = () => {\n      clearTimeout(timeout);\n    };\n    cancelers.push(cancel);\n    return cancel;\n  };\n  const {\n    host,\n    hostname\n  } = options;\n  const timeoutHandler = (delay, event) => {\n    request.destroy(new TimeoutError(delay, event));\n  };\n  const cancelTimeouts = () => {\n    for (const cancel of cancelers) {\n      cancel();\n    }\n    unhandleAll();\n  };\n  request.once('error', error => {\n    cancelTimeouts();\n    // Save original behavior\n    /* istanbul ignore next */\n    if (request.listenerCount('error') === 0) {\n      throw error;\n    }\n  });\n  if (delays.request !== undefined) {\n    const cancelTimeout = addTimeout(delays.request, timeoutHandler, 'request');\n    once(request, 'response', response => {\n      once(response, 'end', cancelTimeout);\n    });\n  }\n  if (delays.socket !== undefined) {\n    const {\n      socket\n    } = delays;\n    const socketTimeoutHandler = () => {\n      timeoutHandler(socket, 'socket');\n    };\n    request.setTimeout(socket, socketTimeoutHandler);\n    // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n    cancelers.push(() => {\n      request.removeListener('timeout', socketTimeoutHandler);\n    });\n  }\n  const hasLookup = delays.lookup !== undefined;\n  const hasConnect = delays.connect !== undefined;\n  const hasSecureConnect = delays.secureConnect !== undefined;\n  const hasSend = delays.send !== undefined;\n  if (hasLookup || hasConnect || hasSecureConnect || hasSend) {\n    once(request, 'socket', socket => {\n      const {\n        socketPath\n      } = request;\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        const hasPath = Boolean(socketPath ?? net.isIP(hostname ?? host ?? '') !== 0);\n        if (hasLookup && !hasPath && socket.address().address === undefined) {\n          const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n          once(socket, 'lookup', cancelTimeout);\n        }\n        if (hasConnect) {\n          const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n          if (hasPath) {\n            once(socket, 'connect', timeConnect());\n          } else {\n            once(socket, 'lookup', error => {\n              if (error === null) {\n                once(socket, 'connect', timeConnect());\n              }\n            });\n          }\n        }\n        if (hasSecureConnect && options.protocol === 'https:') {\n          once(socket, 'connect', () => {\n            const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n            once(socket, 'secureConnect', cancelTimeout);\n          });\n        }\n      }\n      if (hasSend) {\n        const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n        /* istanbul ignore next: hard to test */\n        if (socket.connecting) {\n          once(socket, 'connect', () => {\n            once(request, 'upload-complete', timeRequest());\n          });\n        } else {\n          once(request, 'upload-complete', timeRequest());\n        }\n      }\n    });\n  }\n  if (delays.response !== undefined) {\n    once(request, 'upload-complete', () => {\n      const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      once(request, 'response', cancelTimeout);\n    });\n  }\n  if (delays.read !== undefined) {\n    once(request, 'response', response => {\n      const cancelTimeout = addTimeout(delays.read, timeoutHandler, 'read');\n      once(response, 'end', cancelTimeout);\n    });\n  }\n  return cancelTimeouts;\n}","map":{"version":3,"names":["net","unhandler","reentry","Symbol","noop","TimeoutError","Error","constructor","threshold","event","Object","defineProperty","enumerable","configurable","writable","value","name","code","timedOut","request","delays","options","cancelers","once","unhandleAll","addTimeout","delay","callback","timeout","setTimeout","unref","cancel","clearTimeout","push","host","hostname","timeoutHandler","destroy","cancelTimeouts","error","listenerCount","undefined","cancelTimeout","response","socket","socketTimeoutHandler","removeListener","hasLookup","lookup","hasConnect","connect","hasSecureConnect","secureConnect","hasSend","send","socketPath","connecting","hasPath","Boolean","isIP","address","timeConnect","protocol","timeRequest","read"],"sources":["D:/LangChainJS/chatpdf/node_modules/got/dist/source/core/timed-out.js"],"sourcesContent":["import net from 'node:net';\nimport unhandler from './utils/unhandle.js';\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nexport class TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        Object.defineProperty(this, \"event\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: event\n        });\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexport default function timedOut(request, delays, options) {\n    if (reentry in request) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandler();\n    const addTimeout = (delay, callback, event) => {\n        const timeout = setTimeout(callback, delay, delay, event);\n        timeout.unref?.();\n        const cancel = () => {\n            clearTimeout(timeout);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        request.destroy(new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        /* istanbul ignore next */\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    if (delays.request !== undefined) {\n        const cancelTimeout = addTimeout(delays.request, timeoutHandler, 'request');\n        once(request, 'response', (response) => {\n            once(response, 'end', cancelTimeout);\n        });\n    }\n    if (delays.socket !== undefined) {\n        const { socket } = delays;\n        const socketTimeoutHandler = () => {\n            timeoutHandler(socket, 'socket');\n        };\n        request.setTimeout(socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    const hasLookup = delays.lookup !== undefined;\n    const hasConnect = delays.connect !== undefined;\n    const hasSecureConnect = delays.secureConnect !== undefined;\n    const hasSend = delays.send !== undefined;\n    if (hasLookup || hasConnect || hasSecureConnect || hasSend) {\n        once(request, 'socket', (socket) => {\n            const { socketPath } = request;\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                const hasPath = Boolean(socketPath ?? net.isIP(hostname ?? host ?? '') !== 0);\n                if (hasLookup && !hasPath && socket.address().address === undefined) {\n                    const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                    once(socket, 'lookup', cancelTimeout);\n                }\n                if (hasConnect) {\n                    const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                    if (hasPath) {\n                        once(socket, 'connect', timeConnect());\n                    }\n                    else {\n                        once(socket, 'lookup', (error) => {\n                            if (error === null) {\n                                once(socket, 'connect', timeConnect());\n                            }\n                        });\n                    }\n                }\n                if (hasSecureConnect && options.protocol === 'https:') {\n                    once(socket, 'connect', () => {\n                        const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                        once(socket, 'secureConnect', cancelTimeout);\n                    });\n                }\n            }\n            if (hasSend) {\n                const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n                /* istanbul ignore next: hard to test */\n                if (socket.connecting) {\n                    once(socket, 'connect', () => {\n                        once(request, 'upload-complete', timeRequest());\n                    });\n                }\n                else {\n                    once(request, 'upload-complete', timeRequest());\n                }\n            }\n        });\n    }\n    if (delays.response !== undefined) {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    if (delays.read !== undefined) {\n        once(request, 'response', (response) => {\n            const cancelTimeout = addTimeout(delays.read, timeoutHandler, 'read');\n            once(response, 'end', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}