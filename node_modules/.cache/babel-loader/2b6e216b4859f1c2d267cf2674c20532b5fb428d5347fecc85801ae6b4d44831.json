{"ast":null,"code":"var fs = require('fs'),\n  path = require('path'),\n  cnst = require('constants');\nvar rimraf = require('rimraf'),\n  os = require('os'),\n  rimrafSync = rimraf.sync;\n\n/* HELPERS */\n\nvar dir = path.resolve(os.tmpdir());\nvar RDWR_EXCL = cnst.O_CREAT | cnst.O_TRUNC | cnst.O_RDWR | cnst.O_EXCL;\nvar promisify = function (callback) {\n  if (typeof callback === 'function') {\n    return [undefined, callback];\n  }\n  var promiseCallback;\n  var promise = new Promise(function (resolve, reject) {\n    promiseCallback = function () {\n      var args = Array.from(arguments);\n      var err = args.shift();\n      process.nextTick(function () {\n        if (err) {\n          reject(err);\n        } else if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args);\n        }\n      });\n    };\n  });\n  return [promise, promiseCallback];\n};\nvar generateName = function (rawAffixes, defaultPrefix) {\n  var affixes = parseAffixes(rawAffixes, defaultPrefix);\n  var now = new Date();\n  var name = [affixes.prefix, now.getFullYear(), now.getMonth(), now.getDate(), '-', process.pid, '-', (Math.random() * 0x100000000 + 1).toString(36), affixes.suffix].join('');\n  return path.join(affixes.dir || dir, name);\n};\nvar parseAffixes = function (rawAffixes, defaultPrefix) {\n  var affixes = {\n    prefix: null,\n    suffix: null\n  };\n  if (rawAffixes) {\n    switch (typeof rawAffixes) {\n      case 'string':\n        affixes.prefix = rawAffixes;\n        break;\n      case 'object':\n        affixes = rawAffixes;\n        break;\n      default:\n        throw new Error(\"Unknown affix declaration: \" + affixes);\n    }\n  } else {\n    affixes.prefix = defaultPrefix;\n  }\n  return affixes;\n};\n\n/* -------------------------------------------------------------------------\n * Don't forget to call track() if you want file tracking and exit handlers!\n * -------------------------------------------------------------------------\n * When any temp file or directory is created, it is added to filesToDelete\n * or dirsToDelete. The first time any temp file is created, a listener is\n * added to remove all temp files and directories at exit.\n */\nvar tracking = false;\nvar track = function (value) {\n  tracking = value !== false;\n  return module.exports; // chainable\n};\nvar exitListenerAttached = false;\nvar filesToDelete = [];\nvar dirsToDelete = [];\nfunction deleteFileOnExit(filePath) {\n  if (!tracking) return false;\n  attachExitListener();\n  filesToDelete.push(filePath);\n}\nfunction deleteDirOnExit(dirPath) {\n  if (!tracking) return false;\n  attachExitListener();\n  dirsToDelete.push(dirPath);\n}\nfunction attachExitListener() {\n  if (!tracking) return false;\n  if (!exitListenerAttached) {\n    process.addListener('exit', cleanupSync);\n    exitListenerAttached = true;\n  }\n}\nfunction cleanupFilesSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n  return count;\n}\nfunction cleanupFiles(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = filesToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // This shouldn't happen; pass error to callback and abort\n      // processing\n      callback(err);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n  return promise;\n}\nfunction cleanupDirsSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n  return count;\n}\nfunction cleanupDirs(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = dirsToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // rimraf handles most \"normal\" errors; pass the error to the\n      // callback and abort processing\n      callback(err, count);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n  return promise;\n}\nfunction cleanupSync() {\n  if (!tracking) {\n    return false;\n  }\n  var fileCount = cleanupFilesSync();\n  var dirCount = cleanupDirsSync();\n  return {\n    files: fileCount,\n    dirs: dirCount\n  };\n}\nfunction cleanup(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  cleanupFiles(function (fileErr, fileCount) {\n    if (fileErr) {\n      callback(fileErr, {\n        files: fileCount\n      });\n    } else {\n      cleanupDirs(function (dirErr, dirCount) {\n        callback(dirErr, {\n          files: fileCount,\n          dirs: dirCount\n        });\n      });\n    }\n  });\n  return promise;\n}\n\n/* DIRECTORIES */\n\nfunction mkdir(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdir(dirPath, parseInt('0700', 8), function (err) {\n    if (!err) {\n      deleteDirOnExit(dirPath);\n    }\n    callback(err, dirPath);\n  });\n  return promise;\n}\nfunction mkdirSync(affixes) {\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdirSync(dirPath, parseInt('0700', 8));\n  deleteDirOnExit(dirPath);\n  return dirPath;\n}\n\n/* FILES */\n\nfunction open(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  var filePath = generateName(affixes, 'f-');\n  fs.open(filePath, RDWR_EXCL, parseInt('0600', 8), function (err, fd) {\n    if (!err) {\n      deleteFileOnExit(filePath);\n    }\n    callback(err, {\n      path: filePath,\n      fd: fd\n    });\n  });\n  return promise;\n}\nfunction openSync(affixes) {\n  var filePath = generateName(affixes, 'f-');\n  var fd = fs.openSync(filePath, RDWR_EXCL, parseInt('0600', 8));\n  deleteFileOnExit(filePath);\n  return {\n    path: filePath,\n    fd: fd\n  };\n}\nfunction createWriteStream(affixes) {\n  var filePath = generateName(affixes, 's-');\n  var stream = fs.createWriteStream(filePath, {\n    flags: RDWR_EXCL,\n    mode: parseInt('0600', 8)\n  });\n  deleteFileOnExit(filePath);\n  return stream;\n}\n\n/* EXPORTS */\n// Settings\nexports.dir = dir;\nexports.track = track;\n// Functions\nexports.mkdir = mkdir;\nexports.mkdirSync = mkdirSync;\nexports.open = open;\nexports.openSync = openSync;\nexports.path = generateName;\nexports.cleanup = cleanup;\nexports.cleanupSync = cleanupSync;\nexports.createWriteStream = createWriteStream;","map":{"version":3,"names":["fs","require","path","cnst","rimraf","os","rimrafSync","sync","dir","resolve","tmpdir","RDWR_EXCL","O_CREAT","O_TRUNC","O_RDWR","O_EXCL","promisify","callback","undefined","promiseCallback","promise","Promise","reject","args","Array","from","arguments","err","shift","process","nextTick","length","generateName","rawAffixes","defaultPrefix","affixes","parseAffixes","now","Date","name","prefix","getFullYear","getMonth","getDate","pid","Math","random","toString","suffix","join","Error","tracking","track","value","module","exports","exitListenerAttached","filesToDelete","dirsToDelete","deleteFileOnExit","filePath","attachExitListener","push","deleteDirOnExit","dirPath","addListener","cleanupSync","cleanupFilesSync","count","toDelete","cleanupFiles","p","left","rimrafCallback","cleanupDirsSync","cleanupDirs","fileCount","dirCount","files","dirs","cleanup","fileErr","dirErr","mkdir","parseInt","mkdirSync","open","fd","openSync","createWriteStream","stream","flags","mode"],"sources":["D:/LangChainJS/chatpdf/node_modules/temp/lib/temp.js"],"sourcesContent":["var fs   = require('fs'),\n    path = require('path'),\n    cnst = require('constants');\n\nvar rimraf     = require('rimraf'),\n    os         = require('os'),\n    rimrafSync = rimraf.sync;\n\n/* HELPERS */\n\nvar dir = path.resolve(os.tmpdir());\n\nvar RDWR_EXCL = cnst.O_CREAT | cnst.O_TRUNC | cnst.O_RDWR | cnst.O_EXCL;\n\nvar promisify = function(callback) {\n  if (typeof callback === 'function') {\n    return [undefined, callback];\n  }\n\n  var promiseCallback;\n  var promise = new Promise(function(resolve, reject) {\n    promiseCallback = function() {\n      var args = Array.from(arguments);\n      var err = args.shift();\n\n      process.nextTick(function() {\n        if (err) {\n          reject(err);\n        } else if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args);\n        }\n      });\n    };\n  });\n\n  return [promise, promiseCallback];\n};\n\nvar generateName = function(rawAffixes, defaultPrefix) {\n  var affixes = parseAffixes(rawAffixes, defaultPrefix);\n  var now = new Date();\n  var name = [affixes.prefix,\n              now.getFullYear(), now.getMonth(), now.getDate(),\n              '-',\n              process.pid,\n              '-',\n              (Math.random() * 0x100000000 + 1).toString(36),\n              affixes.suffix].join('');\n  return path.join(affixes.dir || dir, name);\n};\n\nvar parseAffixes = function(rawAffixes, defaultPrefix) {\n  var affixes = {prefix: null, suffix: null};\n  if(rawAffixes) {\n    switch (typeof(rawAffixes)) {\n    case 'string':\n      affixes.prefix = rawAffixes;\n      break;\n    case 'object':\n      affixes = rawAffixes;\n      break;\n    default:\n      throw new Error(\"Unknown affix declaration: \" + affixes);\n    }\n  } else {\n    affixes.prefix = defaultPrefix;\n  }\n  return affixes;\n};\n\n/* -------------------------------------------------------------------------\n * Don't forget to call track() if you want file tracking and exit handlers!\n * -------------------------------------------------------------------------\n * When any temp file or directory is created, it is added to filesToDelete\n * or dirsToDelete. The first time any temp file is created, a listener is\n * added to remove all temp files and directories at exit.\n */\nvar tracking = false;\nvar track = function(value) {\n  tracking = (value !== false);\n  return module.exports; // chainable\n};\nvar exitListenerAttached = false;\nvar filesToDelete = [];\nvar dirsToDelete = [];\n\nfunction deleteFileOnExit(filePath) {\n  if (!tracking) return false;\n  attachExitListener();\n  filesToDelete.push(filePath);\n}\n\nfunction deleteDirOnExit(dirPath) {\n  if (!tracking) return false;\n  attachExitListener();\n  dirsToDelete.push(dirPath);\n}\n\nfunction attachExitListener() {\n  if (!tracking) return false;\n  if (!exitListenerAttached) {\n    process.addListener('exit', cleanupSync);\n    exitListenerAttached = true;\n  }\n}\n\nfunction cleanupFilesSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n  return count;\n}\n\nfunction cleanupFiles(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = filesToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function(err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // This shouldn't happen; pass error to callback and abort\n      // processing\n      callback(err);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n  return promise;\n}\n\nfunction cleanupDirsSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n  return count;\n}\n\nfunction cleanupDirs(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = dirsToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // rimraf handles most \"normal\" errors; pass the error to the\n      // callback and abort processing\n      callback(err, count);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n  return promise;\n}\n\nfunction cleanupSync() {\n  if (!tracking) {\n    return false;\n  }\n  var fileCount = cleanupFilesSync();\n  var dirCount  = cleanupDirsSync();\n  return {files: fileCount, dirs: dirCount};\n}\n\nfunction cleanup(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  cleanupFiles(function(fileErr, fileCount) {\n    if (fileErr) {\n      callback(fileErr, {files: fileCount});\n    } else {\n      cleanupDirs(function(dirErr, dirCount) {\n        callback(dirErr, {files: fileCount, dirs: dirCount});\n      });\n    }\n  });\n  return promise;\n}\n\n/* DIRECTORIES */\n\nfunction mkdir(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdir(dirPath, parseInt('0700', 8), function(err) {\n    if (!err) {\n      deleteDirOnExit(dirPath);\n    }\n    callback(err, dirPath);\n  });\n  return promise;\n}\n\nfunction mkdirSync(affixes) {\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdirSync(dirPath, parseInt('0700', 8));\n  deleteDirOnExit(dirPath);\n  return dirPath;\n}\n\n/* FILES */\n\nfunction open(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  var filePath = generateName(affixes, 'f-');\n  fs.open(filePath, RDWR_EXCL, parseInt('0600', 8), function(err, fd) {\n    if (!err) {\n      deleteFileOnExit(filePath);\n    }\n    callback(err, {path: filePath, fd: fd});\n  });\n  return promise;\n}\n\nfunction openSync(affixes) {\n  var filePath = generateName(affixes, 'f-');\n  var fd = fs.openSync(filePath, RDWR_EXCL, parseInt('0600', 8));\n  deleteFileOnExit(filePath);\n  return {path: filePath, fd: fd};\n}\n\nfunction createWriteStream(affixes) {\n  var filePath = generateName(affixes, 's-');\n  var stream = fs.createWriteStream(filePath, {flags: RDWR_EXCL, mode: parseInt('0600', 8)});\n  deleteFileOnExit(filePath);\n  return stream;\n}\n\n/* EXPORTS */\n// Settings\nexports.dir               = dir;\nexports.track             = track;\n// Functions\nexports.mkdir             = mkdir;\nexports.mkdirSync         = mkdirSync;\nexports.open              = open;\nexports.openSync          = openSync;\nexports.path              = generateName;\nexports.cleanup           = cleanup;\nexports.cleanupSync       = cleanupSync;\nexports.createWriteStream = createWriteStream;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}