{"ast":null,"code":"/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar spawn = require('child_process').spawn;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the single page searchable pdf file on disk\n * This function buffers all the output from stdout and sends it back as a string.\n * Since we only handle single pages of pdf text here the amount of text is small\n * and therefore we don't need to use a stream\n *\n * @return {ReadStream} the entire output from stdout\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function (pdf_path, options, callback) {\n  if (options === undefined) options = {};\n  if (options.layout === undefined) options.layout = true;\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    var child = spawn('pdftotext', (options.layout ? ['-layout'] : []).concat([pdf_path, '-']));\n    var stdout = child.stdout;\n    var stderr = child.stderr;\n    var output = '';\n    stdout.setEncoding('utf8');\n    stderr.setEncoding('utf8');\n    stderr.on('data', function (data) {\n      return callback(data, null);\n    });\n    // buffer the stdout output\n    stdout.on('data', function (data) {\n      output += data;\n    });\n    stdout.on('close', function (data) {\n      return callback(null, output);\n    });\n  });\n};\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Array} files is an array of the absolute paths to the single\n * page pdf files. Each entry in this array is an object with fields\n * <file_name> and <file_path> set\n * @return callback(<maybe error>, files)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, {\n    followLinks: false\n  });\n  walker.on('file', function (root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({\n        file_path: file_path,\n        file_name: stat.name\n      });\n      next();\n    }\n  });\n  walker.on('end', function () {\n    return callback(null, file_paths);\n  });\n}\n\n/**\n * Cleanup any single page pdfs on error\n */\nfunction cleanup_directory(directory_path, callback) {\n  // only remove the folder at directory_path if it exists\n  fs.exists(directory_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    rimraf(directory_path, callback);\n  });\n}\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n}\n;","map":{"version":3,"names":["path","require","temp","exec","spawn","fs","walk","async","rimraf","module","exports","pdf_path","options","callback","undefined","layout","confirm_file_exists","err","child","concat","stdout","stderr","output","setEncoding","on","data","get_pdfs_in_directory","directory_path","file_paths","files","walker","followLinks","root","stat","next","name","match","file_path","join","push","file_name","cleanup_directory","exists"],"sources":["D:/LangChainJS/chatpdf/node_modules/pdf-extract/lib/searchable.js"],"sourcesContent":["/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar spawn = require('child_process').spawn;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the single page searchable pdf file on disk\n * This function buffers all the output from stdout and sends it back as a string.\n * Since we only handle single pages of pdf text here the amount of text is small\n * and therefore we don't need to use a stream\n *\n * @return {ReadStream} the entire output from stdout\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function(pdf_path, options, callback) {\n  if(options===undefined)options={};\n  if(options.layout===undefined)options.layout=true;\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) { return callback(err); }\n    var child = spawn('pdftotext', (options.layout ? ['-layout'] : []).concat([pdf_path, '-']));\n    var stdout = child.stdout;\n    var stderr = child.stderr;\n    var output = '';\n    stdout.setEncoding('utf8');\n    stderr.setEncoding('utf8');\n    stderr.on('data', function(data) {\n      return callback(data, null);\n    });\n    // buffer the stdout output\n    stdout.on('data', function(data) {\n      output += data;\n    });\n    stdout.on('close', function(data) {\n      return callback(null, output);\n    });\n  });\n}\n\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Array} files is an array of the absolute paths to the single\n * page pdf files. Each entry in this array is an object with fields\n * <file_name> and <file_path> set\n * @return callback(<maybe error>, files)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, { followLinks: false});\n  walker.on('file', function(root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({file_path: file_path, file_name: stat.name});\n      next();\n    }\n  });\n  walker.on('end', function() {\n    return callback(null, file_paths);\n  });\n}\n\n/**\n * Cleanup any single page pdfs on error\n */\nfunction cleanup_directory(directory_path, callback) {\n  // only remove the folder at directory_path if it exists\n  fs.exists(directory_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    rimraf(directory_path, callback);\n  });\n}\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}