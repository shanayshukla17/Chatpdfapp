{"ast":null,"code":"import process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError } from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@sindresorhus/is';\nimport getStream from 'get-stream';\nimport { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError } from './errors.js';\nconst {\n  buffer: getStreamAsBuffer\n} = getStream;\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade'];\nconst noop = () => {};\nexport default class Request extends Duplex {\n  constructor(url, options, defaults) {\n    super({\n      // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n      autoDestroy: false,\n      // It needs to be zero because we're just proxying the data to another stream\n      highWaterMark: 0\n    });\n    // @ts-expect-error - Ignoring for now.\n    Object.defineProperty(this, 'constructor', {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_noPipe\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"response\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"requestUrl\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"redirectUrls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"retryCount\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_stopRetry\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_downloadedSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_uploadedSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_stopReading\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_pipedServerResponses\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_request\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_responseSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_bodySize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_unproxyEvents\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isFromCache\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_cannotHaveBody\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_triggerRead\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_cancelTimeouts\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_removeListeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_nativeResponse\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_flushed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_aborted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // We need this because `this._request` if `undefined` when using cache\n    Object.defineProperty(this, \"_requestInitialized\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._downloadedSize = 0;\n    this._uploadedSize = 0;\n    this._stopReading = false;\n    this._pipedServerResponses = new Set();\n    this._cannotHaveBody = false;\n    this._unproxyEvents = noop;\n    this._triggerRead = false;\n    this._cancelTimeouts = noop;\n    this._removeListeners = noop;\n    this._jobs = [];\n    this._flushed = false;\n    this._requestInitialized = false;\n    this._aborted = false;\n    this.redirectUrls = [];\n    this.retryCount = 0;\n    this._stopRetry = noop;\n    this.on('pipe', source => {\n      if (source?.headers) {\n        Object.assign(this.options.headers, source.headers);\n      }\n    });\n    this.on('newListener', event => {\n      if (event === 'retry' && this.listenerCount('retry') > 0) {\n        throw new Error('A retry listener has been attached already.');\n      }\n    });\n    try {\n      this.options = new Options(url, options, defaults);\n      if (!this.options.url) {\n        if (this.options.prefixUrl === '') {\n          throw new TypeError('Missing `url` property');\n        }\n        this.options.url = '';\n      }\n      this.requestUrl = this.options.url;\n    } catch (error) {\n      const {\n        options\n      } = error;\n      if (options) {\n        this.options = options;\n      }\n      this.flush = async () => {\n        this.flush = async () => {};\n        this.destroy(error);\n      };\n      return;\n    }\n    // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n    // The below is run only once.\n    const {\n      body\n    } = this.options;\n    if (is.nodeStream(body)) {\n      body.once('error', error => {\n        if (this._flushed) {\n          this._beforeError(new UploadError(error, this));\n        } else {\n          this.flush = async () => {\n            this.flush = async () => {};\n            this._beforeError(new UploadError(error, this));\n          };\n        }\n      });\n    }\n    if (this.options.signal) {\n      const abort = () => {\n        this.destroy(new AbortError(this));\n      };\n      if (this.options.signal.aborted) {\n        abort();\n      } else {\n        this.options.signal.addEventListener('abort', abort);\n        this._removeListeners = () => {\n          this.options.signal?.removeEventListener('abort', abort);\n        };\n      }\n    }\n  }\n  async flush() {\n    if (this._flushed) {\n      return;\n    }\n    this._flushed = true;\n    try {\n      await this._finalizeBody();\n      if (this.destroyed) {\n        return;\n      }\n      await this._makeRequest();\n      if (this.destroyed) {\n        this._request?.destroy();\n        return;\n      }\n      // Queued writes etc.\n      for (const job of this._jobs) {\n        job();\n      }\n      // Prevent memory leak\n      this._jobs.length = 0;\n      this._requestInitialized = true;\n    } catch (error) {\n      this._beforeError(error);\n    }\n  }\n  _beforeError(error) {\n    if (this._stopReading) {\n      return;\n    }\n    const {\n      response,\n      options\n    } = this;\n    const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n    this._stopReading = true;\n    if (!(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n    const typedError = error;\n    void (async () => {\n      // Node.js parser is really weird.\n      // It emits post-request Parse Errors on the same instance as previous request. WTF.\n      // Therefore we need to check if it has been destroyed as well.\n      //\n      // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n      // but makes the response unreadable. So we additionally need to check `response.readable`.\n      if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n        // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n        response.setEncoding(this.readableEncoding);\n        const success = await this._setRawBody(response);\n        if (success) {\n          response.body = response.rawBody.toString();\n        }\n      }\n      if (this.listenerCount('retry') !== 0) {\n        let backoff;\n        try {\n          let retryAfter;\n          if (response && 'retry-after' in response.headers) {\n            retryAfter = Number(response.headers['retry-after']);\n            if (Number.isNaN(retryAfter)) {\n              retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n              if (retryAfter <= 0) {\n                retryAfter = 1;\n              }\n            } else {\n              retryAfter *= 1000;\n            }\n          }\n          const retryOptions = options.retry;\n          backoff = await retryOptions.calculateDelay({\n            attemptCount,\n            retryOptions,\n            error: typedError,\n            retryAfter,\n            computedValue: calculateRetryDelay({\n              attemptCount,\n              retryOptions,\n              error: typedError,\n              retryAfter,\n              computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY\n            })\n          });\n        } catch (error_) {\n          void this._error(new RequestError(error_.message, error_, this));\n          return;\n        }\n        if (backoff) {\n          await new Promise(resolve => {\n            const timeout = setTimeout(resolve, backoff);\n            this._stopRetry = () => {\n              clearTimeout(timeout);\n              resolve();\n            };\n          });\n          // Something forced us to abort the retry\n          if (this.destroyed) {\n            return;\n          }\n          try {\n            for (const hook of this.options.hooks.beforeRetry) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(typedError, this.retryCount + 1);\n            }\n          } catch (error_) {\n            void this._error(new RequestError(error_.message, error, this));\n            return;\n          }\n          // Something forced us to abort the retry\n          if (this.destroyed) {\n            return;\n          }\n          this.destroy();\n          this.emit('retry', this.retryCount + 1, error, updatedOptions => {\n            const request = new Request(options.url, updatedOptions, options);\n            request.retryCount = this.retryCount + 1;\n            process.nextTick(() => {\n              void request.flush();\n            });\n            return request;\n          });\n          return;\n        }\n      }\n      void this._error(typedError);\n    })();\n  }\n  _read() {\n    this._triggerRead = true;\n    const {\n      response\n    } = this;\n    if (response && !this._stopReading) {\n      // We cannot put this in the `if` above\n      // because `.read()` also triggers the `end` event\n      if (response.readableLength) {\n        this._triggerRead = false;\n      }\n      let data;\n      while ((data = response.read()) !== null) {\n        this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n        const progress = this.downloadProgress;\n        if (progress.percent < 1) {\n          this.emit('downloadProgress', progress);\n        }\n        this.push(data);\n      }\n    }\n  }\n  _write(chunk, encoding, callback) {\n    const write = () => {\n      this._writeRequest(chunk, encoding, callback);\n    };\n    if (this._requestInitialized) {\n      write();\n    } else {\n      this._jobs.push(write);\n    }\n  }\n  _final(callback) {\n    const endRequest = () => {\n      // We need to check if `this._request` is present,\n      // because it isn't when we use cache.\n      if (!this._request || this._request.destroyed) {\n        callback();\n        return;\n      }\n      this._request.end(error => {\n        // The request has been destroyed before `_final` finished.\n        // See https://github.com/nodejs/node/issues/39356\n        if (this._request._writableState?.errored) {\n          return;\n        }\n        if (!error) {\n          this._bodySize = this._uploadedSize;\n          this.emit('uploadProgress', this.uploadProgress);\n          this._request.emit('upload-complete');\n        }\n        callback(error);\n      });\n    };\n    if (this._requestInitialized) {\n      endRequest();\n    } else {\n      this._jobs.push(endRequest);\n    }\n  }\n  _destroy(error, callback) {\n    this._stopReading = true;\n    this.flush = async () => {};\n    // Prevent further retries\n    this._stopRetry();\n    this._cancelTimeouts();\n    this._removeListeners();\n    if (this.options) {\n      const {\n        body\n      } = this.options;\n      if (is.nodeStream(body)) {\n        body.destroy();\n      }\n    }\n    if (this._request) {\n      this._request.destroy();\n    }\n    if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n    callback(error);\n  }\n  pipe(destination, options) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.add(destination);\n    }\n    return super.pipe(destination, options);\n  }\n  unpipe(destination) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.delete(destination);\n    }\n    super.unpipe(destination);\n    return this;\n  }\n  async _finalizeBody() {\n    const {\n      options\n    } = this;\n    const {\n      headers\n    } = options;\n    const isForm = !is.undefined(options.form);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const isJSON = !is.undefined(options.json);\n    const isBody = !is.undefined(options.body);\n    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n    this._cannotHaveBody = cannotHaveBody;\n    if (isForm || isJSON || isBody) {\n      if (cannotHaveBody) {\n        throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n      }\n      // Serialize body\n      const noContentType = !is.string(headers['content-type']);\n      if (isBody) {\n        // Body is spec-compliant FormData\n        if (isFormDataLike(options.body)) {\n          const encoder = new FormDataEncoder(options.body);\n          if (noContentType) {\n            headers['content-type'] = encoder.headers['Content-Type'];\n          }\n          if ('Content-Length' in encoder.headers) {\n            headers['content-length'] = encoder.headers['Content-Length'];\n          }\n          options.body = encoder.encode();\n        }\n        // Special case for https://github.com/form-data/form-data\n        if (isFormData(options.body) && noContentType) {\n          headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n        }\n      } else if (isForm) {\n        if (noContentType) {\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n        }\n        const {\n          form\n        } = options;\n        options.form = undefined;\n        options.body = new URLSearchParams(form).toString();\n      } else {\n        if (noContentType) {\n          headers['content-type'] = 'application/json';\n        }\n        const {\n          json\n        } = options;\n        options.json = undefined;\n        options.body = options.stringifyJson(json);\n      }\n      const uploadBodySize = await getBodySize(options.body, options.headers);\n      // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n      // A user agent SHOULD send a Content-Length in a request message when\n      // no Transfer-Encoding is sent and the request method defines a meaning\n      // for an enclosed payload body.  For example, a Content-Length header\n      // field is normally sent in a POST request even when the value is 0\n      // (indicating an empty payload body).  A user agent SHOULD NOT send a\n      // Content-Length header field when the request message does not contain\n      // a payload body and the method semantics do not anticipate such a\n      // body.\n      if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n        headers['content-length'] = String(uploadBodySize);\n      }\n    }\n    if (options.responseType === 'json' && !('accept' in options.headers)) {\n      options.headers.accept = 'application/json';\n    }\n    this._bodySize = Number(headers['content-length']) || undefined;\n  }\n  async _onResponseBase(response) {\n    // This will be called e.g. when using cache so we need to check if this request has been aborted.\n    if (this.isAborted) {\n      return;\n    }\n    const {\n      options\n    } = this;\n    const {\n      url\n    } = options;\n    this._nativeResponse = response;\n    if (options.decompress) {\n      response = decompressResponse(response);\n    }\n    const statusCode = response.statusCode;\n    const typedResponse = response;\n    typedResponse.statusMessage = typedResponse.statusMessage ?? http.STATUS_CODES[statusCode];\n    typedResponse.url = options.url.toString();\n    typedResponse.requestUrl = this.requestUrl;\n    typedResponse.redirectUrls = this.redirectUrls;\n    typedResponse.request = this;\n    typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n    typedResponse.ip = this.ip;\n    typedResponse.retryCount = this.retryCount;\n    typedResponse.ok = isResponseOk(typedResponse);\n    this._isFromCache = typedResponse.isFromCache;\n    this._responseSize = Number(response.headers['content-length']) || undefined;\n    this.response = typedResponse;\n    response.once('end', () => {\n      this._responseSize = this._downloadedSize;\n      this.emit('downloadProgress', this.downloadProgress);\n    });\n    response.once('error', error => {\n      this._aborted = true;\n      // Force clean-up, because some packages don't do this.\n      // TODO: Fix decompress-response\n      response.destroy();\n      this._beforeError(new ReadError(error, this));\n    });\n    response.once('aborted', () => {\n      this._aborted = true;\n      this._beforeError(new ReadError({\n        name: 'Error',\n        message: 'The server aborted pending request',\n        code: 'ECONNRESET'\n      }, this));\n    });\n    this.emit('downloadProgress', this.downloadProgress);\n    const rawCookies = response.headers['set-cookie'];\n    if (is.object(options.cookieJar) && rawCookies) {\n      let promises = rawCookies.map(async rawCookie => options.cookieJar.setCookie(rawCookie, url.toString()));\n      if (options.ignoreInvalidCookies) {\n        promises = promises.map(async promise => {\n          try {\n            await promise;\n          } catch {}\n        });\n      }\n      try {\n        await Promise.all(promises);\n      } catch (error) {\n        this._beforeError(error);\n        return;\n      }\n    }\n    // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n    if (this.isAborted) {\n      return;\n    }\n    if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n      // We're being redirected, we don't care about the response.\n      // It'd be best to abort the request, but we can't because\n      // we would have to sacrifice the TCP connection. We don't want that.\n      response.resume();\n      this._cancelTimeouts();\n      this._unproxyEvents();\n      if (this.redirectUrls.length >= options.maxRedirects) {\n        this._beforeError(new MaxRedirectsError(this));\n        return;\n      }\n      this._request = undefined;\n      const updatedOptions = new Options(undefined, undefined, this.options);\n      const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n      const canRewrite = statusCode !== 307 && statusCode !== 308;\n      const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n      if (serverRequestedGet || userRequestedGet) {\n        updatedOptions.method = 'GET';\n        updatedOptions.body = undefined;\n        updatedOptions.json = undefined;\n        updatedOptions.form = undefined;\n        delete updatedOptions.headers['content-length'];\n      }\n      try {\n        // We need this in order to support UTF-8\n        const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n        const redirectUrl = new URL(redirectBuffer, url);\n        if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n          this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n          return;\n        }\n        // Redirecting to a different site, clear sensitive data.\n        if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n          if ('host' in updatedOptions.headers) {\n            delete updatedOptions.headers.host;\n          }\n          if ('cookie' in updatedOptions.headers) {\n            delete updatedOptions.headers.cookie;\n          }\n          if ('authorization' in updatedOptions.headers) {\n            delete updatedOptions.headers.authorization;\n          }\n          if (updatedOptions.username || updatedOptions.password) {\n            updatedOptions.username = '';\n            updatedOptions.password = '';\n          }\n        } else {\n          redirectUrl.username = updatedOptions.username;\n          redirectUrl.password = updatedOptions.password;\n        }\n        this.redirectUrls.push(redirectUrl);\n        updatedOptions.prefixUrl = '';\n        updatedOptions.url = redirectUrl;\n        for (const hook of updatedOptions.hooks.beforeRedirect) {\n          // eslint-disable-next-line no-await-in-loop\n          await hook(updatedOptions, typedResponse);\n        }\n        this.emit('redirect', updatedOptions, typedResponse);\n        this.options = updatedOptions;\n        await this._makeRequest();\n      } catch (error) {\n        this._beforeError(error);\n        return;\n      }\n      return;\n    }\n    // `HTTPError`s always have `error.response.body` defined.\n    // Therefore we cannot retry if `options.throwHttpErrors` is false.\n    // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n    // but that wouldn't be possible since the body would be already read in `error.response.body`.\n    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n      this._beforeError(new HTTPError(typedResponse));\n      return;\n    }\n    response.on('readable', () => {\n      if (this._triggerRead) {\n        this._read();\n      }\n    });\n    this.on('resume', () => {\n      response.resume();\n    });\n    this.on('pause', () => {\n      response.pause();\n    });\n    response.once('end', () => {\n      this.push(null);\n    });\n    if (this._noPipe) {\n      const success = await this._setRawBody();\n      if (success) {\n        this.emit('response', response);\n      }\n      return;\n    }\n    this.emit('response', response);\n    for (const destination of this._pipedServerResponses) {\n      if (destination.headersSent) {\n        continue;\n      }\n      // eslint-disable-next-line guard-for-in\n      for (const key in response.headers) {\n        const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n        const value = response.headers[key];\n        if (isAllowed) {\n          destination.setHeader(key, value);\n        }\n      }\n      destination.statusCode = statusCode;\n    }\n  }\n  async _setRawBody(from = this) {\n    if (from.readableEnded) {\n      return false;\n    }\n    try {\n      // Errors are emitted via the `error` event\n      const rawBody = await getStreamAsBuffer(from);\n      // TODO: Switch to this:\n      // let rawBody = await from.toArray();\n      // rawBody = Buffer.concat(rawBody);\n      // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n      // So in order to check if this was really successfull, we need to check if it has been properly ended.\n      if (!this.isAborted) {\n        this.response.rawBody = rawBody;\n        return true;\n      }\n    } catch {}\n    return false;\n  }\n  async _onResponse(response) {\n    try {\n      await this._onResponseBase(response);\n    } catch (error) {\n      /* istanbul ignore next: better safe than sorry */\n      this._beforeError(error);\n    }\n  }\n  _onRequest(request) {\n    const {\n      options\n    } = this;\n    const {\n      timeout,\n      url\n    } = options;\n    timer(request);\n    if (this.options.http2) {\n      // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n      request.setTimeout(0);\n    }\n    this._cancelTimeouts = timedOut(request, timeout, url);\n    const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n    request.once(responseEventName, response => {\n      void this._onResponse(response);\n    });\n    request.once('error', error => {\n      this._aborted = true;\n      // Force clean-up, because some packages (e.g. nock) don't do this.\n      request.destroy();\n      error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n      this._beforeError(error);\n    });\n    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n    this._request = request;\n    this.emit('uploadProgress', this.uploadProgress);\n    this._sendBody();\n    this.emit('request', request);\n  }\n  async _asyncWrite(chunk) {\n    return new Promise((resolve, reject) => {\n      super.write(chunk, error => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve();\n      });\n    });\n  }\n  _sendBody() {\n    // Send body\n    const {\n      body\n    } = this.options;\n    const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n    if (is.nodeStream(body)) {\n      body.pipe(currentRequest);\n    } else if (is.generator(body) || is.asyncGenerator(body)) {\n      (async () => {\n        try {\n          for await (const chunk of body) {\n            await this._asyncWrite(chunk);\n          }\n          super.end();\n        } catch (error) {\n          this._beforeError(error);\n        }\n      })();\n    } else if (!is.undefined(body)) {\n      this._writeRequest(body, undefined, () => {});\n      currentRequest.end();\n    } else if (this._cannotHaveBody || this._noPipe) {\n      currentRequest.end();\n    }\n  }\n  _prepareCache(cache) {\n    if (!cacheableStore.has(cache)) {\n      const cacheableRequest = new CacheableRequest((requestOptions, handler) => {\n        const result = requestOptions._request(requestOptions, handler);\n        // TODO: remove this when `cacheable-request` supports async request functions.\n        if (is.promise(result)) {\n          // We only need to implement the error handler in order to support HTTP2 caching.\n          // The result will be a promise anyway.\n          // @ts-expect-error ignore\n          result.once = (event, handler) => {\n            if (event === 'error') {\n              (async () => {\n                try {\n                  await result;\n                } catch (error) {\n                  handler(error);\n                }\n              })();\n            } else if (event === 'abort') {\n              // The empty catch is needed here in case when\n              // it rejects before it's `await`ed in `_makeRequest`.\n              (async () => {\n                try {\n                  const request = await result;\n                  request.once('abort', handler);\n                } catch {}\n              })();\n            } else {\n              /* istanbul ignore next: safety check */\n              throw new Error(`Unknown HTTP2 promise event: ${event}`);\n            }\n            return result;\n          };\n        }\n        return result;\n      }, cache);\n      cacheableStore.set(cache, cacheableRequest.request());\n    }\n  }\n  async _createCacheableRequest(url, options) {\n    return new Promise((resolve, reject) => {\n      // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n      Object.assign(options, urlToOptions(url));\n      let request;\n      // TODO: Fix `cacheable-response`. This is ugly.\n      const cacheRequest = cacheableStore.get(options.cache)(options, async response => {\n        response._readableState.autoDestroy = false;\n        if (request) {\n          const fix = () => {\n            if (response.req) {\n              response.complete = response.req.res.complete;\n            }\n          };\n          response.prependOnceListener('end', fix);\n          fix();\n          (await request).emit('cacheableResponse', response);\n        }\n        resolve(response);\n      });\n      cacheRequest.once('error', reject);\n      cacheRequest.once('request', async requestOrPromise => {\n        request = requestOrPromise;\n        resolve(request);\n      });\n    });\n  }\n  async _makeRequest() {\n    const {\n      options\n    } = this;\n    const {\n      headers,\n      username,\n      password\n    } = options;\n    const cookieJar = options.cookieJar;\n    for (const key in headers) {\n      if (is.undefined(headers[key])) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete headers[key];\n      } else if (is.null_(headers[key])) {\n        throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n      }\n    }\n    if (options.decompress && is.undefined(headers['accept-encoding'])) {\n      headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n    }\n    if (username || password) {\n      const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n      headers.authorization = `Basic ${credentials}`;\n    }\n    // Set cookies\n    if (cookieJar) {\n      const cookieString = await cookieJar.getCookieString(options.url.toString());\n      if (is.nonEmptyString(cookieString)) {\n        headers.cookie = cookieString;\n      }\n    }\n    // Reset `prefixUrl`\n    options.prefixUrl = '';\n    let request;\n    for (const hook of options.hooks.beforeRequest) {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await hook(options);\n      if (!is.undefined(result)) {\n        // @ts-expect-error Skip the type mismatch to support abstract responses\n        request = () => result;\n        break;\n      }\n    }\n    if (!request) {\n      request = options.getRequestFunction();\n    }\n    const url = options.url;\n    this._requestOptions = options.createNativeRequestOptions();\n    if (options.cache) {\n      this._requestOptions._request = request;\n      this._requestOptions.cache = options.cache;\n      this._requestOptions.body = options.body;\n      this._prepareCache(options.cache);\n    }\n    // Cache support\n    const fn = options.cache ? this._createCacheableRequest : request;\n    try {\n      // We can't do `await fn(...)`,\n      // because stream `error` event can be emitted before `Promise.resolve()`.\n      let requestOrResponse = fn(url, this._requestOptions);\n      if (is.promise(requestOrResponse)) {\n        requestOrResponse = await requestOrResponse;\n      }\n      // Fallback\n      if (is.undefined(requestOrResponse)) {\n        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n        if (is.promise(requestOrResponse)) {\n          requestOrResponse = await requestOrResponse;\n        }\n      }\n      if (isClientRequest(requestOrResponse)) {\n        this._onRequest(requestOrResponse);\n      } else if (this.writable) {\n        this.once('finish', () => {\n          void this._onResponse(requestOrResponse);\n        });\n        this._sendBody();\n      } else {\n        void this._onResponse(requestOrResponse);\n      }\n    } catch (error) {\n      if (error instanceof CacheableCacheError) {\n        throw new CacheError(error, this);\n      }\n      throw error;\n    }\n  }\n  async _error(error) {\n    try {\n      if (error instanceof HTTPError && !this.options.throwHttpErrors) {\n        // This branch can be reached only when using the Promise API\n        // Skip calling the hooks on purpose.\n        // See https://github.com/sindresorhus/got/issues/2103\n      } else {\n        for (const hook of this.options.hooks.beforeError) {\n          // eslint-disable-next-line no-await-in-loop\n          error = await hook(error);\n        }\n      }\n    } catch (error_) {\n      error = new RequestError(error_.message, error_, this);\n    }\n    this.destroy(error);\n  }\n  _writeRequest(chunk, encoding, callback) {\n    if (!this._request || this._request.destroyed) {\n      // Probably the `ClientRequest` instance will throw\n      return;\n    }\n    this._request.write(chunk, encoding, error => {\n      // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n      if (!error && !this._request.destroyed) {\n        this._uploadedSize += Buffer.byteLength(chunk, encoding);\n        const progress = this.uploadProgress;\n        if (progress.percent < 1) {\n          this.emit('uploadProgress', progress);\n        }\n      }\n      callback(error);\n    });\n  }\n  /**\n  The remote IP address.\n  */\n  get ip() {\n    return this.socket?.remoteAddress;\n  }\n  /**\n  Indicates whether the request has been aborted or not.\n  */\n  get isAborted() {\n    return this._aborted;\n  }\n  get socket() {\n    return this._request?.socket ?? undefined;\n  }\n  /**\n  Progress event for downloading (receiving a response).\n  */\n  get downloadProgress() {\n    let percent;\n    if (this._responseSize) {\n      percent = this._downloadedSize / this._responseSize;\n    } else if (this._responseSize === this._downloadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n    return {\n      percent,\n      transferred: this._downloadedSize,\n      total: this._responseSize\n    };\n  }\n  /**\n  Progress event for uploading (sending a request).\n  */\n  get uploadProgress() {\n    let percent;\n    if (this._bodySize) {\n      percent = this._uploadedSize / this._bodySize;\n    } else if (this._bodySize === this._uploadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n    return {\n      percent,\n      transferred: this._uploadedSize,\n      total: this._bodySize\n    };\n  }\n  /**\n  The object contains the following properties:\n   - `start` - Time when the request started.\n  - `socket` - Time when a socket was assigned to the request.\n  - `lookup` - Time when the DNS lookup finished.\n  - `connect` - Time when the socket successfully connected.\n  - `secureConnect` - Time when the socket securely connected.\n  - `upload` - Time when the request finished uploading.\n  - `response` - Time when the request fired `response` event.\n  - `end` - Time when the response fired `end` event.\n  - `error` - Time when the request fired `error` event.\n  - `abort` - Time when the request fired `abort` event.\n  - `phases`\n      - `wait` - `timings.socket - timings.start`\n      - `dns` - `timings.lookup - timings.socket`\n      - `tcp` - `timings.connect - timings.lookup`\n      - `tls` - `timings.secureConnect - timings.connect`\n      - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n      - `firstByte` - `timings.response - timings.upload`\n      - `download` - `timings.end - timings.response`\n      - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n   If something has not been measured yet, it will be `undefined`.\n   __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n  */\n  get timings() {\n    return this._request?.timings;\n  }\n  /**\n  Whether the response was retrieved from the cache.\n  */\n  get isFromCache() {\n    return this._isFromCache;\n  }\n  get reusedSocket() {\n    return this._request?.reusedSocket;\n  }\n}","map":{"version":3,"names":["process","Buffer","Duplex","http","ServerResponse","timer","CacheableRequest","CacheError","CacheableCacheError","decompressResponse","is","getStream","FormDataEncoder","isFormData","isFormDataLike","getBodySize","proxyEvents","timedOut","TimeoutError","TimedOutTimeoutError","urlToOptions","WeakableMap","calculateRetryDelay","Options","isResponseOk","isClientRequest","isUnixSocketURL","RequestError","ReadError","MaxRedirectsError","HTTPError","UploadError","AbortError","buffer","getStreamAsBuffer","supportsBrotli","string","versions","brotli","methodsWithoutBody","Set","cacheableStore","redirectCodes","proxiedRequestEvents","noop","Request","constructor","url","options","defaults","autoDestroy","highWaterMark","Object","defineProperty","enumerable","configurable","writable","value","_downloadedSize","_uploadedSize","_stopReading","_pipedServerResponses","_cannotHaveBody","_unproxyEvents","_triggerRead","_cancelTimeouts","_removeListeners","_jobs","_flushed","_requestInitialized","_aborted","redirectUrls","retryCount","_stopRetry","on","source","headers","assign","event","listenerCount","Error","prefixUrl","TypeError","requestUrl","error","flush","destroy","body","nodeStream","once","_beforeError","signal","abort","aborted","addEventListener","removeEventListener","_finalizeBody","destroyed","_makeRequest","_request","job","length","response","attemptCount","name","message","typedError","readable","rawBody","socket","setEncoding","readableEncoding","success","_setRawBody","toString","backoff","retryAfter","Number","isNaN","Date","parse","now","retryOptions","retry","calculateDelay","computedValue","maxRetryAfter","timeout","request","POSITIVE_INFINITY","error_","_error","Promise","resolve","setTimeout","clearTimeout","hook","hooks","beforeRetry","emit","updatedOptions","nextTick","_read","readableLength","data","read","progress","downloadProgress","percent","push","_write","chunk","encoding","callback","write","_writeRequest","_final","endRequest","end","_writableState","errored","_bodySize","uploadProgress","_destroy","undefined","pipe","destination","add","unpipe","delete","isForm","form","isJSON","json","isBody","cannotHaveBody","has","method","allowGetBody","noContentType","encoder","encode","getBoundary","URLSearchParams","stringifyJson","uploadBodySize","String","responseType","accept","_onResponseBase","isAborted","_nativeResponse","decompress","statusCode","typedResponse","statusMessage","STATUS_CODES","isFromCache","fromCache","ip","ok","_isFromCache","_responseSize","code","rawCookies","object","cookieJar","promises","map","rawCookie","setCookie","ignoreInvalidCookies","promise","all","followRedirect","location","resume","maxRedirects","serverRequestedGet","canRewrite","userRequestedGet","methodRewriting","redirectBuffer","from","redirectUrl","URL","hostname","port","host","cookie","authorization","username","password","beforeRedirect","isStream","throwHttpErrors","pause","_noPipe","headersSent","key","isAllowed","setHeader","readableEnded","_onResponse","_onRequest","http2","responseEventName","cache","timings","_sendBody","_asyncWrite","reject","currentRequest","generator","asyncGenerator","_prepareCache","cacheableRequest","requestOptions","handler","result","set","_createCacheableRequest","cacheRequest","get","_readableState","fix","req","complete","res","prependOnceListener","requestOrPromise","null_","credentials","cookieString","getCookieString","nonEmptyString","beforeRequest","getRequestFunction","_requestOptions","createNativeRequestOptions","fn","requestOrResponse","getFallbackRequestFunction","beforeError","byteLength","remoteAddress","transferred","total","reusedSocket"],"sources":["D:/LangChainJS/chatpdf/node_modules/got/dist/source/core/index.js"],"sourcesContent":["import process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError, } from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is from '@sindresorhus/is';\nimport getStream from 'get-stream';\nimport { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError, } from './errors.js';\nconst { buffer: getStreamAsBuffer } = getStream;\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n];\nconst noop = () => { };\nexport default class Request extends Duplex {\n    constructor(url, options, defaults) {\n        super({\n            // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0,\n        });\n        // @ts-expect-error - Ignoring for now.\n        Object.defineProperty(this, 'constructor', {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_noPipe\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"response\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"requestUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"redirectUrls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"retryCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopRetry\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_downloadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_uploadedSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_stopReading\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pipedServerResponses\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_request\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_responseSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_bodySize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_unproxyEvents\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isFromCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cannotHaveBody\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_triggerRead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_cancelTimeouts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_removeListeners\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_nativeResponse\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_flushed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_aborted\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // We need this because `this._request` if `undefined` when using cache\n        Object.defineProperty(this, \"_requestInitialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this._downloadedSize = 0;\n        this._uploadedSize = 0;\n        this._stopReading = false;\n        this._pipedServerResponses = new Set();\n        this._cannotHaveBody = false;\n        this._unproxyEvents = noop;\n        this._triggerRead = false;\n        this._cancelTimeouts = noop;\n        this._removeListeners = noop;\n        this._jobs = [];\n        this._flushed = false;\n        this._requestInitialized = false;\n        this._aborted = false;\n        this.redirectUrls = [];\n        this.retryCount = 0;\n        this._stopRetry = noop;\n        this.on('pipe', (source) => {\n            if (source?.headers) {\n                Object.assign(this.options.headers, source.headers);\n            }\n        });\n        this.on('newListener', event => {\n            if (event === 'retry' && this.listenerCount('retry') > 0) {\n                throw new Error('A retry listener has been attached already.');\n            }\n        });\n        try {\n            this.options = new Options(url, options, defaults);\n            if (!this.options.url) {\n                if (this.options.prefixUrl === '') {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.options.url = '';\n            }\n            this.requestUrl = this.options.url;\n        }\n        catch (error) {\n            const { options } = error;\n            if (options) {\n                this.options = options;\n            }\n            this.flush = async () => {\n                this.flush = async () => { };\n                this.destroy(error);\n            };\n            return;\n        }\n        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n        // The below is run only once.\n        const { body } = this.options;\n        if (is.nodeStream(body)) {\n            body.once('error', error => {\n                if (this._flushed) {\n                    this._beforeError(new UploadError(error, this));\n                }\n                else {\n                    this.flush = async () => {\n                        this.flush = async () => { };\n                        this._beforeError(new UploadError(error, this));\n                    };\n                }\n            });\n        }\n        if (this.options.signal) {\n            const abort = () => {\n                this.destroy(new AbortError(this));\n            };\n            if (this.options.signal.aborted) {\n                abort();\n            }\n            else {\n                this.options.signal.addEventListener('abort', abort);\n                this._removeListeners = () => {\n                    this.options.signal?.removeEventListener('abort', abort);\n                };\n            }\n        }\n    }\n    async flush() {\n        if (this._flushed) {\n            return;\n        }\n        this._flushed = true;\n        try {\n            await this._finalizeBody();\n            if (this.destroyed) {\n                return;\n            }\n            await this._makeRequest();\n            if (this.destroyed) {\n                this._request?.destroy();\n                return;\n            }\n            // Queued writes etc.\n            for (const job of this._jobs) {\n                job();\n            }\n            // Prevent memory leak\n            this._jobs.length = 0;\n            this._requestInitialized = true;\n        }\n        catch (error) {\n            this._beforeError(error);\n        }\n    }\n    _beforeError(error) {\n        if (this._stopReading) {\n            return;\n        }\n        const { response, options } = this;\n        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n        this._stopReading = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        void (async () => {\n            // Node.js parser is really weird.\n            // It emits post-request Parse Errors on the same instance as previous request. WTF.\n            // Therefore we need to check if it has been destroyed as well.\n            //\n            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n            // but makes the response unreadable. So we additionally need to check `response.readable`.\n            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n                response.setEncoding(this.readableEncoding);\n                const success = await this._setRawBody(response);\n                if (success) {\n                    response.body = response.rawBody.toString();\n                }\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        }\n                        else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    const retryOptions = options.retry;\n                    backoff = await retryOptions.calculateDelay({\n                        attemptCount,\n                        retryOptions,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculateRetryDelay({\n                            attemptCount,\n                            retryOptions,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,\n                        }),\n                    });\n                }\n                catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    await new Promise(resolve => {\n                        const timeout = setTimeout(resolve, backoff);\n                        this._stopRetry = () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        };\n                    });\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    try {\n                        for (const hook of this.options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(typedError, this.retryCount + 1);\n                        }\n                    }\n                    catch (error_) {\n                        void this._error(new RequestError(error_.message, error, this));\n                        return;\n                    }\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    this.destroy();\n                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {\n                        const request = new Request(options.url, updatedOptions, options);\n                        request.retryCount = this.retryCount + 1;\n                        process.nextTick(() => {\n                            void request.flush();\n                        });\n                        return request;\n                    });\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this._triggerRead = true;\n        const { response } = this;\n        if (response && !this._stopReading) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this._triggerRead = false;\n            }\n            let data;\n            while ((data = response.read()) !== null) {\n                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    _write(chunk, encoding, callback) {\n        const write = () => {\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this._requestInitialized) {\n            write();\n        }\n        else {\n            this._jobs.push(write);\n        }\n    }\n    _final(callback) {\n        const endRequest = () => {\n            // We need to check if `this._request` is present,\n            // because it isn't when we use cache.\n            if (!this._request || this._request.destroyed) {\n                callback();\n                return;\n            }\n            this._request.end((error) => {\n                // The request has been destroyed before `_final` finished.\n                // See https://github.com/nodejs/node/issues/39356\n                if (this._request._writableState?.errored) {\n                    return;\n                }\n                if (!error) {\n                    this._bodySize = this._uploadedSize;\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this._request.emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this._requestInitialized) {\n            endRequest();\n        }\n        else {\n            this._jobs.push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        this._stopReading = true;\n        this.flush = async () => { };\n        // Prevent further retries\n        this._stopRetry();\n        this._cancelTimeouts();\n        this._removeListeners();\n        if (this.options) {\n            const { body } = this.options;\n            if (is.nodeStream(body)) {\n                body.destroy();\n            }\n        }\n        if (this._request) {\n            this._request.destroy();\n        }\n        if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    pipe(destination, options) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is.undefined(options.form);\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        const isJSON = !is.undefined(options.json);\n        const isBody = !is.undefined(options.body);\n        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (isForm || isJSON || isBody) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            // Serialize body\n            const noContentType = !is.string(headers['content-type']);\n            if (isBody) {\n                // Body is spec-compliant FormData\n                if (isFormDataLike(options.body)) {\n                    const encoder = new FormDataEncoder(options.body);\n                    if (noContentType) {\n                        headers['content-type'] = encoder.headers['Content-Type'];\n                    }\n                    if ('Content-Length' in encoder.headers) {\n                        headers['content-length'] = encoder.headers['Content-Length'];\n                    }\n                    options.body = encoder.encode();\n                }\n                // Special case for https://github.com/form-data/form-data\n                if (isFormData(options.body) && noContentType) {\n                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                }\n            }\n            else if (isForm) {\n                if (noContentType) {\n                    headers['content-type'] = 'application/x-www-form-urlencoded';\n                }\n                const { form } = options;\n                options.form = undefined;\n                options.body = (new URLSearchParams(form)).toString();\n            }\n            else {\n                if (noContentType) {\n                    headers['content-type'] = 'application/json';\n                }\n                const { json } = options;\n                options.json = undefined;\n                options.body = options.stringifyJson(json);\n            }\n            const uploadBodySize = await getBodySize(options.body, options.headers);\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n            // A user agent SHOULD send a Content-Length in a request message when\n            // no Transfer-Encoding is sent and the request method defines a meaning\n            // for an enclosed payload body.  For example, a Content-Length header\n            // field is normally sent in a POST request even when the value is 0\n            // (indicating an empty payload body).  A user agent SHOULD NOT send a\n            // Content-Length header field when the request message does not contain\n            // a payload body and the method semantics do not anticipate such a\n            // body.\n            if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n                headers['content-length'] = String(uploadBodySize);\n            }\n        }\n        if (options.responseType === 'json' && !('accept' in options.headers)) {\n            options.headers.accept = 'application/json';\n        }\n        this._bodySize = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        // This will be called e.g. when using cache so we need to check if this request has been aborted.\n        if (this.isAborted) {\n            return;\n        }\n        const { options } = this;\n        const { url } = options;\n        this._nativeResponse = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ?? http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirectUrls;\n        typedResponse.request = this;\n        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        typedResponse.ok = isResponseOk(typedResponse);\n        this._isFromCache = typedResponse.isFromCache;\n        this._responseSize = Number(response.headers['content-length']) || undefined;\n        this.response = typedResponse;\n        response.once('end', () => {\n            this._responseSize = this._downloadedSize;\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', () => {\n            this._aborted = true;\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET',\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                promises = promises.map(async (promise) => {\n                    try {\n                        await promise;\n                    }\n                    catch { }\n                });\n            }\n            try {\n                await Promise.all(promises);\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n        if (this.isAborted) {\n            return;\n        }\n        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            response.resume();\n            this._cancelTimeouts();\n            this._unproxyEvents();\n            if (this.redirectUrls.length >= options.maxRedirects) {\n                this._beforeError(new MaxRedirectsError(this));\n                return;\n            }\n            this._request = undefined;\n            const updatedOptions = new Options(undefined, undefined, this.options);\n            const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n            const canRewrite = statusCode !== 307 && statusCode !== 308;\n            const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n            if (serverRequestedGet || userRequestedGet) {\n                updatedOptions.method = 'GET';\n                updatedOptions.body = undefined;\n                updatedOptions.json = undefined;\n                updatedOptions.form = undefined;\n                delete updatedOptions.headers['content-length'];\n            }\n            try {\n                // We need this in order to support UTF-8\n                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                const redirectUrl = new URL(redirectBuffer, url);\n                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n                    return;\n                }\n                // Redirecting to a different site, clear sensitive data.\n                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                    if ('host' in updatedOptions.headers) {\n                        delete updatedOptions.headers.host;\n                    }\n                    if ('cookie' in updatedOptions.headers) {\n                        delete updatedOptions.headers.cookie;\n                    }\n                    if ('authorization' in updatedOptions.headers) {\n                        delete updatedOptions.headers.authorization;\n                    }\n                    if (updatedOptions.username || updatedOptions.password) {\n                        updatedOptions.username = '';\n                        updatedOptions.password = '';\n                    }\n                }\n                else {\n                    redirectUrl.username = updatedOptions.username;\n                    redirectUrl.password = updatedOptions.password;\n                }\n                this.redirectUrls.push(redirectUrl);\n                updatedOptions.prefixUrl = '';\n                updatedOptions.url = redirectUrl;\n                for (const hook of updatedOptions.hooks.beforeRedirect) {\n                    // eslint-disable-next-line no-await-in-loop\n                    await hook(updatedOptions, typedResponse);\n                }\n                this.emit('redirect', updatedOptions, typedResponse);\n                this.options = updatedOptions;\n                await this._makeRequest();\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n            return;\n        }\n        // `HTTPError`s always have `error.response.body` defined.\n        // Therefore we cannot retry if `options.throwHttpErrors` is false.\n        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n        // but that wouldn't be possible since the body would be already read in `error.response.body`.\n        if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', () => {\n            if (this._triggerRead) {\n                this._read();\n            }\n        });\n        this.on('resume', () => {\n            response.resume();\n        });\n        this.on('pause', () => {\n            response.pause();\n        });\n        response.once('end', () => {\n            this.push(null);\n        });\n        if (this._noPipe) {\n            const success = await this._setRawBody();\n            if (success) {\n                this.emit('response', response);\n            }\n            return;\n        }\n        this.emit('response', response);\n        for (const destination of this._pipedServerResponses) {\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for (const key in response.headers) {\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _setRawBody(from = this) {\n        if (from.readableEnded) {\n            return false;\n        }\n        try {\n            // Errors are emitted via the `error` event\n            const rawBody = await getStreamAsBuffer(from);\n            // TODO: Switch to this:\n            // let rawBody = await from.toArray();\n            // rawBody = Buffer.concat(rawBody);\n            // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n            // So in order to check if this was really successfull, we need to check if it has been properly ended.\n            if (!this.isAborted) {\n                this.response.rawBody = rawBody;\n                return true;\n            }\n        }\n        catch { }\n        return false;\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        }\n        catch (error) {\n            /* istanbul ignore next: better safe than sorry */\n            this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        timer(request);\n        if (this.options.http2) {\n            // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n            request.setTimeout(0);\n        }\n        this._cancelTimeouts = timedOut(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response) => {\n            void this._onResponse(response);\n        });\n        request.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n        this._request = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        this._sendBody();\n        this.emit('request', request);\n    }\n    async _asyncWrite(chunk) {\n        return new Promise((resolve, reject) => {\n            super.write(chunk, error => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n    _sendBody() {\n        // Send body\n        const { body } = this.options;\n        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n        if (is.nodeStream(body)) {\n            body.pipe(currentRequest);\n        }\n        else if (is.generator(body) || is.asyncGenerator(body)) {\n            (async () => {\n                try {\n                    for await (const chunk of body) {\n                        await this._asyncWrite(chunk);\n                    }\n                    super.end();\n                }\n                catch (error) {\n                    this._beforeError(error);\n                }\n            })();\n        }\n        else if (!is.undefined(body)) {\n            this._writeRequest(body, undefined, () => { });\n            currentRequest.end();\n        }\n        else if (this._cannotHaveBody || this._noPipe) {\n            currentRequest.end();\n        }\n    }\n    _prepareCache(cache) {\n        if (!cacheableStore.has(cache)) {\n            const cacheableRequest = new CacheableRequest(((requestOptions, handler) => {\n                const result = requestOptions._request(requestOptions, handler);\n                // TODO: remove this when `cacheable-request` supports async request functions.\n                if (is.promise(result)) {\n                    // We only need to implement the error handler in order to support HTTP2 caching.\n                    // The result will be a promise anyway.\n                    // @ts-expect-error ignore\n                    result.once = (event, handler) => {\n                        if (event === 'error') {\n                            (async () => {\n                                try {\n                                    await result;\n                                }\n                                catch (error) {\n                                    handler(error);\n                                }\n                            })();\n                        }\n                        else if (event === 'abort') {\n                            // The empty catch is needed here in case when\n                            // it rejects before it's `await`ed in `_makeRequest`.\n                            (async () => {\n                                try {\n                                    const request = (await result);\n                                    request.once('abort', handler);\n                                }\n                                catch { }\n                            })();\n                        }\n                        else {\n                            /* istanbul ignore next: safety check */\n                            throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                        }\n                        return result;\n                    };\n                }\n                return result;\n            }), cache);\n            cacheableStore.set(cache, cacheableRequest.request());\n        }\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject) => {\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, urlToOptions(url));\n            let request;\n            // TODO: Fix `cacheable-response`. This is ugly.\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    const fix = () => {\n                        if (response.req) {\n                            response.complete = response.req.res.complete;\n                        }\n                    };\n                    response.prependOnceListener('end', fix);\n                    fix();\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise) => {\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        const { options } = this;\n        const { headers, username, password } = options;\n        const cookieJar = options.cookieJar;\n        for (const key in headers) {\n            if (is.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            }\n            else if (is.null_(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        if (username || password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            headers.authorization = `Basic ${credentials}`;\n        }\n        // Set cookies\n        if (cookieJar) {\n            const cookieString = await cookieJar.getCookieString(options.url.toString());\n            if (is.nonEmptyString(cookieString)) {\n                headers.cookie = cookieString;\n            }\n        }\n        // Reset `prefixUrl`\n        options.prefixUrl = '';\n        let request;\n        for (const hook of options.hooks.beforeRequest) {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                request = () => result;\n                break;\n            }\n        }\n        if (!request) {\n            request = options.getRequestFunction();\n        }\n        const url = options.url;\n        this._requestOptions = options.createNativeRequestOptions();\n        if (options.cache) {\n            this._requestOptions._request = request;\n            this._requestOptions.cache = options.cache;\n            this._requestOptions.body = options.body;\n            this._prepareCache(options.cache);\n        }\n        // Cache support\n        const fn = options.cache ? this._createCacheableRequest : request;\n        try {\n            // We can't do `await fn(...)`,\n            // because stream `error` event can be emitted before `Promise.resolve()`.\n            let requestOrResponse = fn(url, this._requestOptions);\n            if (is.promise(requestOrResponse)) {\n                requestOrResponse = await requestOrResponse;\n            }\n            // Fallback\n            if (is.undefined(requestOrResponse)) {\n                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n                if (is.promise(requestOrResponse)) {\n                    requestOrResponse = await requestOrResponse;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n            }\n            else if (this.writable) {\n                this.once('finish', () => {\n                    void this._onResponse(requestOrResponse);\n                });\n                this._sendBody();\n            }\n            else {\n                void this._onResponse(requestOrResponse);\n            }\n        }\n        catch (error) {\n            if (error instanceof CacheableCacheError) {\n                throw new CacheError(error, this);\n            }\n            throw error;\n        }\n    }\n    async _error(error) {\n        try {\n            if (error instanceof HTTPError && !this.options.throwHttpErrors) {\n                // This branch can be reached only when using the Promise API\n                // Skip calling the hooks on purpose.\n                // See https://github.com/sindresorhus/got/issues/2103\n            }\n            else {\n                for (const hook of this.options.hooks.beforeError) {\n                    // eslint-disable-next-line no-await-in-loop\n                    error = await hook(error);\n                }\n            }\n        }\n        catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (!this._request || this._request.destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._request.write(chunk, encoding, (error) => {\n            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n            if (!error && !this._request.destroyed) {\n                this._uploadedSize += Buffer.byteLength(chunk, encoding);\n                const progress = this.uploadProgress;\n                if (progress.percent < 1) {\n                    this.emit('uploadProgress', progress);\n                }\n            }\n            callback(error);\n        });\n    }\n    /**\n    The remote IP address.\n    */\n    get ip() {\n        return this.socket?.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n    get isAborted() {\n        return this._aborted;\n    }\n    get socket() {\n        return this._request?.socket ?? undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n    get downloadProgress() {\n        let percent;\n        if (this._responseSize) {\n            percent = this._downloadedSize / this._responseSize;\n        }\n        else if (this._responseSize === this._downloadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._downloadedSize,\n            total: this._responseSize,\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n    get uploadProgress() {\n        let percent;\n        if (this._bodySize) {\n            percent = this._uploadedSize / this._bodySize;\n        }\n        else if (this._bodySize === this._uploadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._uploadedSize,\n            total: this._bodySize,\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n    get timings() {\n        return this._request?.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n    get isFromCache() {\n        return this._isFromCache;\n    }\n    get reusedSocket() {\n        return this._request?.reusedSocket;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}