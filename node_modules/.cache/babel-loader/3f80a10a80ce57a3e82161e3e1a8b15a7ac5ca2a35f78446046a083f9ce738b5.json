{"ast":null,"code":"import EventEmitter from 'node:events';\nimport urlLib from 'node:url';\nimport crypto from 'node:crypto';\nimport stream, { PassThrough as PassThroughStream } from 'node:stream';\nimport normalizeUrl from 'normalize-url';\nimport getStream from 'get-stream';\nimport CachePolicy from 'http-cache-semantics';\nimport Response from 'responselike';\nimport Keyv from 'keyv';\nimport mimicResponse from 'mimic-response';\nimport { CacheError, RequestError } from './types.js';\nclass CacheableRequest {\n  constructor(cacheRequest, cacheAdapter) {\n    this.hooks = new Map();\n    this.request = () => (options, cb) => {\n      let url;\n      if (typeof options === 'string') {\n        url = normalizeUrlObject(urlLib.parse(options));\n        options = {};\n      } else if (options instanceof urlLib.URL) {\n        url = normalizeUrlObject(urlLib.parse(options.toString()));\n        options = {};\n      } else {\n        const [pathname, ...searchParts] = (options.path ?? '').split('?');\n        const search = searchParts.length > 0 ? `?${searchParts.join('?')}` : '';\n        url = normalizeUrlObject({\n          ...options,\n          pathname,\n          search\n        });\n      }\n      options = {\n        headers: {},\n        method: 'GET',\n        cache: true,\n        strictTtl: false,\n        automaticFailover: false,\n        ...options,\n        ...urlObjectToRequestOptions(url)\n      };\n      options.headers = Object.fromEntries(entries(options.headers).map(([key, value]) => [key.toLowerCase(), value]));\n      const ee = new EventEmitter();\n      const normalizedUrlString = normalizeUrl(urlLib.format(url), {\n        stripWWW: false,\n        removeTrailingSlash: false,\n        stripAuthentication: false\n      });\n      let key = `${options.method}:${normalizedUrlString}`;\n      // POST, PATCH, and PUT requests may be cached, depending on the response\n      // cache-control headers. As a result, the body of the request should be\n      // added to the cache key in order to avoid collisions.\n      if (options.body && options.method !== undefined && ['POST', 'PATCH', 'PUT'].includes(options.method)) {\n        if (options.body instanceof stream.Readable) {\n          // Streamed bodies should completely skip the cache because they may\n          // or may not be hashable and in either case the stream would need to\n          // close before the cache key could be generated.\n          options.cache = false;\n        } else {\n          key += `:${crypto.createHash('md5').update(options.body).digest('hex')}`;\n        }\n      }\n      let revalidate = false;\n      let madeRequest = false;\n      const makeRequest = options_ => {\n        madeRequest = true;\n        let requestErrored = false;\n        let requestErrorCallback = () => {};\n        const requestErrorPromise = new Promise(resolve => {\n          requestErrorCallback = () => {\n            if (!requestErrored) {\n              requestErrored = true;\n              resolve();\n            }\n          };\n        });\n        const handler = async response => {\n          if (revalidate) {\n            response.status = response.statusCode;\n            const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);\n            if (!revalidatedPolicy.modified) {\n              response.resume();\n              await new Promise(resolve => {\n                // Skipping 'error' handler cause 'error' event should't be emitted for 304 response\n                response.once('end', resolve);\n              });\n              const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());\n              response = new Response({\n                statusCode: revalidate.statusCode,\n                headers,\n                body: revalidate.body,\n                url: revalidate.url\n              });\n              response.cachePolicy = revalidatedPolicy.policy;\n              response.fromCache = true;\n            }\n          }\n          if (!response.fromCache) {\n            response.cachePolicy = new CachePolicy(options_, response, options_);\n            response.fromCache = false;\n          }\n          let clonedResponse;\n          if (options_.cache && response.cachePolicy.storable()) {\n            clonedResponse = cloneResponse(response);\n            (async () => {\n              try {\n                const bodyPromise = getStream.buffer(response);\n                await Promise.race([requestErrorPromise, new Promise(resolve => response.once('end', resolve)), new Promise(resolve => response.once('close', resolve)) // eslint-disable-line no-promise-executor-return\n                ]);\n                const body = await bodyPromise;\n                let value = {\n                  url: response.url,\n                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                  body,\n                  cachePolicy: response.cachePolicy.toObject()\n                };\n                let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n                if (options_.maxTtl) {\n                  ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;\n                }\n                if (this.hooks.size > 0) {\n                  /* eslint-disable no-await-in-loop */\n                  for (const key_ of this.hooks.keys()) {\n                    value = await this.runHook(key_, value, response);\n                  }\n                  /* eslint-enable no-await-in-loop */\n                }\n                await this.cache.set(key, value, ttl);\n              } catch (error) {\n                ee.emit('error', new CacheError(error));\n              }\n            })();\n          } else if (options_.cache && revalidate) {\n            (async () => {\n              try {\n                await this.cache.delete(key);\n              } catch (error) {\n                ee.emit('error', new CacheError(error));\n              }\n            })();\n          }\n          ee.emit('response', clonedResponse ?? response);\n          if (typeof cb === 'function') {\n            cb(clonedResponse ?? response);\n          }\n        };\n        try {\n          const request_ = this.cacheRequest(options_, handler);\n          request_.once('error', requestErrorCallback);\n          request_.once('abort', requestErrorCallback);\n          request_.once('destroy', requestErrorCallback);\n          ee.emit('request', request_);\n        } catch (error) {\n          ee.emit('error', new RequestError(error));\n        }\n      };\n      (async () => {\n        const get = async options_ => {\n          await Promise.resolve();\n          const cacheEntry = options_.cache ? await this.cache.get(key) : undefined;\n          if (cacheEntry === undefined && !options_.forceRefresh) {\n            makeRequest(options_);\n            return;\n          }\n          const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {\n            const headers = convertHeaders(policy.responseHeaders());\n            const response = new Response({\n              statusCode: cacheEntry.statusCode,\n              headers,\n              body: cacheEntry.body,\n              url: cacheEntry.url\n            });\n            response.cachePolicy = policy;\n            response.fromCache = true;\n            ee.emit('response', response);\n            if (typeof cb === 'function') {\n              cb(response);\n            }\n          } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {\n            await this.cache.delete(key);\n            options_.headers = policy.revalidationHeaders(options_);\n            makeRequest(options_);\n          } else {\n            revalidate = cacheEntry;\n            options_.headers = policy.revalidationHeaders(options_);\n            makeRequest(options_);\n          }\n        };\n        const errorHandler = error => ee.emit('error', new CacheError(error));\n        if (this.cache instanceof Keyv) {\n          const cachek = this.cache;\n          cachek.once('error', errorHandler);\n          ee.on('error', () => cachek.removeListener('error', errorHandler));\n          ee.on('response', () => cachek.removeListener('error', errorHandler));\n        }\n        try {\n          await get(options);\n        } catch (error) {\n          if (options.automaticFailover && !madeRequest) {\n            makeRequest(options);\n          }\n          ee.emit('error', new CacheError(error));\n        }\n      })();\n      return ee;\n    };\n    this.addHook = (name, fn) => {\n      if (!this.hooks.has(name)) {\n        this.hooks.set(name, fn);\n      }\n    };\n    this.removeHook = name => this.hooks.delete(name);\n    this.getHook = name => this.hooks.get(name);\n    this.runHook = async (name, ...args) => this.hooks.get(name)?.(...args);\n    if (cacheAdapter instanceof Keyv) {\n      this.cache = cacheAdapter;\n    } else if (typeof cacheAdapter === 'string') {\n      this.cache = new Keyv({\n        uri: cacheAdapter,\n        namespace: 'cacheable-request'\n      });\n    } else {\n      this.cache = new Keyv({\n        store: cacheAdapter,\n        namespace: 'cacheable-request'\n      });\n    }\n    this.request = this.request.bind(this);\n    this.cacheRequest = cacheRequest;\n  }\n}\nconst entries = Object.entries;\nconst cloneResponse = response => {\n  const clone = new PassThroughStream({\n    autoDestroy: false\n  });\n  mimicResponse(response, clone);\n  return response.pipe(clone);\n};\nconst urlObjectToRequestOptions = url => {\n  const options = {\n    ...url\n  };\n  options.path = `${url.pathname || '/'}${url.search || ''}`;\n  delete options.pathname;\n  delete options.search;\n  return options;\n};\nconst normalizeUrlObject = url => (\n// If url was parsed by url.parse or new URL:\n// - hostname will be set\n// - host will be hostname[:port]\n// - port will be set if it was explicit in the parsed string\n// Otherwise, url was from request options:\n// - hostname or host may be set\n// - host shall not have port encoded\n{\n  protocol: url.protocol,\n  auth: url.auth,\n  hostname: url.hostname || url.host || 'localhost',\n  port: url.port,\n  pathname: url.pathname,\n  search: url.search\n});\nconst convertHeaders = headers => {\n  const result = [];\n  for (const name of Object.keys(headers)) {\n    result[name.toLowerCase()] = headers[name];\n  }\n  return result;\n};\nexport default CacheableRequest;\nexport * from './types.js';\nexport const onResponse = 'onResponse';","map":{"version":3,"names":["EventEmitter","urlLib","crypto","stream","PassThrough","PassThroughStream","normalizeUrl","getStream","CachePolicy","Response","Keyv","mimicResponse","CacheError","RequestError","CacheableRequest","constructor","cacheRequest","cacheAdapter","hooks","Map","request","options","cb","url","normalizeUrlObject","parse","URL","toString","pathname","searchParts","path","split","search","length","join","headers","method","cache","strictTtl","automaticFailover","urlObjectToRequestOptions","Object","fromEntries","entries","map","key","value","toLowerCase","ee","normalizedUrlString","format","stripWWW","removeTrailingSlash","stripAuthentication","body","undefined","includes","Readable","createHash","update","digest","revalidate","madeRequest","makeRequest","options_","requestErrored","requestErrorCallback","requestErrorPromise","Promise","resolve","handler","response","status","statusCode","revalidatedPolicy","fromObject","cachePolicy","modified","resume","once","convertHeaders","policy","responseHeaders","fromCache","clonedResponse","storable","cloneResponse","bodyPromise","buffer","race","toObject","ttl","timeToLive","maxTtl","Math","min","size","key_","keys","runHook","set","error","emit","delete","request_","get","cacheEntry","forceRefresh","satisfiesWithoutRevalidation","Date","now","revalidationHeaders","errorHandler","cachek","on","removeListener","addHook","name","fn","has","removeHook","getHook","args","uri","namespace","store","bind","clone","autoDestroy","pipe","protocol","auth","hostname","host","port","result","onResponse"],"sources":["D:\\LangChainJS\\chatpdf\\node_modules\\cacheable-request\\src\\index.ts"],"sourcesContent":["import EventEmitter from 'node:events';\nimport urlLib from 'node:url';\nimport crypto from 'node:crypto';\nimport stream, {PassThrough as PassThroughStream} from 'node:stream';\nimport {IncomingMessage} from 'node:http';\nimport normalizeUrl from 'normalize-url';\nimport getStream from 'get-stream';\nimport CachePolicy from 'http-cache-semantics';\nimport Response from 'responselike';\nimport Keyv from 'keyv';\nimport mimicResponse from 'mimic-response';\nimport {RequestFn, StorageAdapter, CacheResponse, CacheValue, CacheableOptions, UrlOption, CacheError, RequestError, Emitter, CacheableRequestFunction} from './types.js';\n\ntype Func = (...args: any[]) => any;\n\nclass CacheableRequest {\n\tcache: StorageAdapter;\n\tcacheRequest: RequestFn;\n\thooks: Map<string, Func> = new Map<string, Func>();\n\tconstructor(cacheRequest: RequestFn, cacheAdapter?: StorageAdapter | string) {\n\t\tif (cacheAdapter instanceof Keyv) {\n\t\t\tthis.cache = cacheAdapter;\n\t\t} else if (typeof cacheAdapter === 'string') {\n\t\t\tthis.cache = new Keyv({\n\t\t\t\turi: cacheAdapter,\n\t\t\t\tnamespace: 'cacheable-request',\n\t\t\t});\n\t\t} else {\n\t\t\tthis.cache = new Keyv({\n\t\t\t\tstore: cacheAdapter,\n\t\t\t\tnamespace: 'cacheable-request',\n\t\t\t});\n\t\t}\n\n\t\tthis.request = this.request.bind(this);\n\t\tthis.cacheRequest = cacheRequest;\n\t}\n\n\trequest = () => (options: CacheableOptions,\n\t\tcb?: (response: CacheResponse) => void): Emitter => {\n\t\tlet url;\n\t\tif (typeof options === 'string') {\n\t\t\turl = normalizeUrlObject(urlLib.parse(options));\n\t\t\toptions = {};\n\t\t} else if (options instanceof urlLib.URL) {\n\t\t\turl = normalizeUrlObject(urlLib.parse(options.toString()));\n\t\t\toptions = {};\n\t\t} else {\n\t\t\tconst [pathname, ...searchParts] = (options.path ?? '').split('?');\n\t\t\tconst search = searchParts.length > 0\n\t\t\t\t? `?${searchParts.join('?')}`\n\t\t\t\t: '';\n\t\t\turl = normalizeUrlObject({...options, pathname, search});\n\t\t}\n\n\t\toptions = {\n\t\t\theaders: {},\n\t\t\tmethod: 'GET',\n\t\t\tcache: true,\n\t\t\tstrictTtl: false,\n\t\t\tautomaticFailover: false,\n\t\t\t...options,\n\t\t\t...urlObjectToRequestOptions(url),\n\t\t};\n\t\toptions.headers = Object.fromEntries(entries(options.headers).map(([key, value]) => [(key as string).toLowerCase(), value]));\n\t\tconst ee: Emitter = new EventEmitter() as Emitter;\n\t\tconst normalizedUrlString = normalizeUrl(urlLib.format(url), {\n\t\t\tstripWWW: false, // eslint-disable-line @typescript-eslint/naming-convention\n\t\t\tremoveTrailingSlash: false,\n\t\t\tstripAuthentication: false,\n\t\t});\n\t\tlet key = `${options.method}:${normalizedUrlString}`;\n\t\t// POST, PATCH, and PUT requests may be cached, depending on the response\n\t\t// cache-control headers. As a result, the body of the request should be\n\t\t// added to the cache key in order to avoid collisions.\n\t\tif (options.body && options.method !== undefined && ['POST', 'PATCH', 'PUT'].includes(options.method)) {\n\t\t\tif (options.body instanceof stream.Readable) {\n\t\t\t\t// Streamed bodies should completely skip the cache because they may\n\t\t\t\t// or may not be hashable and in either case the stream would need to\n\t\t\t\t// close before the cache key could be generated.\n\t\t\t\toptions.cache = false;\n\t\t\t} else {\n\t\t\t\tkey += `:${crypto.createHash('md5').update(options.body).digest('hex')}`;\n\t\t\t}\n\t\t}\n\n\t\tlet revalidate: any = false;\n\t\tlet madeRequest = false;\n\t\tconst makeRequest = (options_: any) => {\n\t\t\tmadeRequest = true;\n\t\t\tlet requestErrored = false;\n\t\t\tlet requestErrorCallback: (...args: any[]) => void = () => {/* do nothing */};\n\n\t\t\tconst requestErrorPromise = new Promise<void>(resolve => {\n\t\t\t\trequestErrorCallback = () => {\n\t\t\t\t\tif (!requestErrored) {\n\t\t\t\t\t\trequestErrored = true;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\tconst handler = async (response: any) => {\n\t\t\t\tif (revalidate) {\n\t\t\t\t\tresponse.status = response.statusCode;\n\t\t\t\t\tconst revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);\n\t\t\t\t\tif (!revalidatedPolicy.modified) {\n\t\t\t\t\t\tresponse.resume();\n\t\t\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\t\t\t// Skipping 'error' handler cause 'error' event should't be emitted for 304 response\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t\t\t.once('end', resolve);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());\n\t\t\t\t\t\tresponse = new Response({statusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url});\n\t\t\t\t\t\tresponse.cachePolicy = revalidatedPolicy.policy;\n\t\t\t\t\t\tresponse.fromCache = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!response.fromCache) {\n\t\t\t\t\tresponse.cachePolicy = new CachePolicy(options_, response, options_);\n\t\t\t\t\tresponse.fromCache = false;\n\t\t\t\t}\n\n\t\t\t\tlet clonedResponse;\n\t\t\t\tif (options_.cache && response.cachePolicy.storable()) {\n\t\t\t\t\tclonedResponse = cloneResponse(response);\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst bodyPromise = getStream.buffer(response);\n\t\t\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\t\t\trequestErrorPromise,\n\t\t\t\t\t\t\t\tnew Promise(resolve => response.once('end', resolve)), // eslint-disable-line no-promise-executor-return\n\t\t\t\t\t\t\t\tnew Promise(resolve => response.once('close', resolve)), // eslint-disable-line no-promise-executor-return\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tconst body = await bodyPromise;\n\t\t\t\t\t\t\tlet value: CacheValue = {\n\t\t\t\t\t\t\t\turl: response.url,\n\t\t\t\t\t\t\t\tstatusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n\t\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t\t\tcachePolicy: response.cachePolicy.toObject(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlet ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\t\t\t\t\t\t\tif (options_.maxTtl) {\n\t\t\t\t\t\t\t\tttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.hooks.size > 0) {\n\t\t\t\t\t\t\t\t/* eslint-disable no-await-in-loop */\n\t\t\t\t\t\t\t\tfor (const key_ of this.hooks.keys()) {\n\t\t\t\t\t\t\t\t\tvalue = await this.runHook(key_, value, response);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/* eslint-enable no-await-in-loop */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tawait this.cache.set(key, value, ttl);\n\t\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t\tee.emit('error', new CacheError(error));\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t} else if (options_.cache && revalidate) {\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.cache.delete(key);\n\t\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t\tee.emit('error', new CacheError(error));\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\n\t\t\t\tee.emit('response', clonedResponse ?? response);\n\t\t\t\tif (typeof cb === 'function') {\n\t\t\t\t\tcb(clonedResponse ?? response);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tconst request_ = this.cacheRequest(options_, handler);\n\t\t\t\trequest_.once('error', requestErrorCallback);\n\t\t\t\trequest_.once('abort', requestErrorCallback);\n\t\t\t\trequest_.once('destroy', requestErrorCallback);\n\t\t\t\tee.emit('request', request_);\n\t\t\t} catch (error: any) {\n\t\t\t\tee.emit('error', new RequestError(error));\n\t\t\t}\n\t\t};\n\n\t\t(async () => {\n\t\t\tconst get = async (options_: any) => {\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tconst cacheEntry = options_.cache ? await this.cache.get(key) : undefined;\n\n\t\t\t\tif (cacheEntry === undefined && !options_.forceRefresh) {\n\t\t\t\t\tmakeRequest(options_);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\t\t\t\tif (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {\n\t\t\t\t\tconst headers = convertHeaders(policy.responseHeaders());\n\t\t\t\t\tconst response: any = new Response({statusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url});\n\t\t\t\t\tresponse.cachePolicy = policy;\n\t\t\t\t\tresponse.fromCache = true;\n\t\t\t\t\tee.emit('response', response);\n\t\t\t\t\tif (typeof cb === 'function') {\n\t\t\t\t\t\tcb(response);\n\t\t\t\t\t}\n\t\t\t\t} else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {\n\t\t\t\t\tawait this.cache.delete(key);\n\t\t\t\t\toptions_.headers = policy.revalidationHeaders(options_);\n\t\t\t\t\tmakeRequest(options_);\n\t\t\t\t} else {\n\t\t\t\t\trevalidate = cacheEntry;\n\t\t\t\t\toptions_.headers = policy.revalidationHeaders(options_);\n\t\t\t\t\tmakeRequest(options_);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst errorHandler = (error: Error) => ee.emit('error', new CacheError(error));\n\t\t\tif (this.cache instanceof Keyv) {\n\t\t\t\tconst cachek = this.cache;\n\t\t\t\tcachek.once('error', errorHandler);\n\t\t\t\tee.on('error', () => cachek.removeListener('error', errorHandler));\n\t\t\t\tee.on('response', () => cachek.removeListener('error', errorHandler));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait get(options);\n\t\t\t} catch (error: any) {\n\t\t\t\tif (options.automaticFailover && !madeRequest) {\n\t\t\t\t\tmakeRequest(options);\n\t\t\t\t}\n\n\t\t\t\tee.emit('error', new CacheError(error));\n\t\t\t}\n\t\t})();\n\n\t\treturn ee;\n\t};\n\n\taddHook = (name: string, fn: Func) => {\n\t\tif (!this.hooks.has(name)) {\n\t\t\tthis.hooks.set(name, fn);\n\t\t}\n\t};\n\n\tremoveHook = (name: string) => this.hooks.delete(name);\n\n\tgetHook = (name: string) => this.hooks.get(name);\n\n\trunHook = async (name: string, ...args: any[]): Promise<CacheValue> => this.hooks.get(name)?.(...args);\n}\n\nconst entries = Object.entries as <T>(object: T) => Array<[keyof T, T[keyof T]]>;\n\nconst cloneResponse = (response: IncomingMessage) => {\n\tconst clone = new PassThroughStream({autoDestroy: false});\n\tmimicResponse(response, clone);\n\n\treturn response.pipe(clone);\n};\n\nconst urlObjectToRequestOptions = (url: any) => {\n\tconst options: UrlOption = {...url};\n\toptions.path = `${url.pathname || '/'}${url.search || ''}`;\n\tdelete options.pathname;\n\tdelete options.search;\n\treturn options;\n};\n\nconst normalizeUrlObject = (url: any) =>\n\t// If url was parsed by url.parse or new URL:\n\t// - hostname will be set\n\t// - host will be hostname[:port]\n\t// - port will be set if it was explicit in the parsed string\n\t// Otherwise, url was from request options:\n\t// - hostname or host may be set\n\t// - host shall not have port encoded\n\t({\n\t\tprotocol: url.protocol,\n\t\tauth: url.auth,\n\t\thostname: url.hostname || url.host || 'localhost',\n\t\tport: url.port,\n\t\tpathname: url.pathname,\n\t\tsearch: url.search,\n\t});\n\nconst convertHeaders = (headers: CachePolicy.Headers) => {\n\tconst result: any = [];\n\tfor (const name of Object.keys(headers)) {\n\t\tresult[name.toLowerCase()] = headers[name];\n\t}\n\n\treturn result;\n};\n\nexport default CacheableRequest;\nexport * from './types.js';\nexport const onResponse = 'onResponse';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}