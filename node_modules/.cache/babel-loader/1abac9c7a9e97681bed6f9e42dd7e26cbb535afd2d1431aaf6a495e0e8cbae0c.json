{"ast":null,"code":"// source/parsers/ppt.ts\n// The text extracter for MS PowerPoint files.\nimport { unzip } from 'fflate';\nimport { parseStringPromise as xmlToJson } from 'xml2js';\nimport encoding from 'text-encoding';\nexport class PptExtractor {\n  constructor() {\n    this.decoder = new encoding.TextDecoder();\n    /**\n     * The type(s) of input acceptable to this method.\n     */\n    this.mimes = ['application/vnd.openxmlformats-officedocument.presentationml.presentation'];\n    /**\n     * Extract text from a PPT file if possible.\n     *\n     * @param payload The input and its type.\n     * @returns The text extracted from the input.\n     */\n    this.apply = async input => {\n      const files = await unzipBuffer(input);\n      const slides = [];\n      for (const file of files) {\n        const {\n          buffer\n        } = file.content;\n        const contents = this.decoder.decode(buffer);\n        const slide = await xmlToJson(contents);\n        const lines = await parseSlideSection(slide);\n        slides.push(lines?.join('\\n'));\n      }\n      const formattedText = slides.join('\\n---\\n') + '\\n';\n      return formattedText;\n    };\n  }\n}\n/**\n * Unzip a PPT file, and return a list of slides.\n *\n * @param buffer The buffer containing the file.\n * @returns The slide files.\n */\nconst unzipBuffer = async input => {\n  // Convert the buffer to a uint-8 array, and pass it to the unzip function.\n  const zipBuffer = new Uint8Array(input.buffer);\n  const ppt = await new Promise((resolve, reject) => {\n    unzip(zipBuffer, (error, result) => {\n      if (error) reject(error);else resolve(result);\n    });\n  });\n  // Filter out the files that don't contain the text on the slides.\n  const files = Object.keys(ppt).filter(name => /ppt\\/slides\\/slide\\d*.xml/.test(name)).map(name => {\n    return {\n      name,\n      content: ppt[name]\n    };\n  });\n  return files;\n};\n/**\n * Extracts text from a section of the slide, recursively.\n *\n * @param slideSection The section of the slide, converted to JSON from XML.\n * @param collectedText The lines of text parsed from the slide so far.\n *\n * @returns The lines of text on the slide.\n */\nconst parseSlideSection = async (slideSection, collectedText) => {\n  // Keep track of the text being collected.\n  const beingCollectedText = collectedText ?? [];\n  // Parse the section according to what type it is.\n  if (Array.isArray(slideSection)) {\n    // If it is, loop through the elements of the array.\n    for (const element of slideSection) {\n      // Collect all the pieces of text from the array.\n      if (typeof element === 'string' && element !== '') {\n        beingCollectedText.push(element);\n      } else {\n        // However, if it is an object or another array, call this function\n        // again to parse that.\n        await parseSlideSection(element, beingCollectedText);\n      }\n    }\n    // Finally, return the collected text.\n    return beingCollectedText;\n  }\n  // If the section is an object, loop through its properties.\n  if (typeof slideSection === 'object') {\n    for (const property of Object.keys(slideSection)) {\n      // Get the value of the property.\n      const value = slideSection[property];\n      // The `pptx` format stores the actual text inside the `a:t` or `_`\n      // properties, so extract text from those properties.\n      // Check if it is a string or array that contains a string. If it is\n      // either, then collect the text content.\n      if (typeof value === 'string') {\n        if ((property === 'a:t' || property === '_') && value !== '') {\n          beingCollectedText.push(value);\n        }\n      } else if (typeof value[0] === 'string') {\n        if ((property === 'a:t' || property === '_') && value[0] !== '') {\n          beingCollectedText.push(value[0]);\n        }\n      } else {\n        // However, if it is an object or another array, call this function\n        // again to parse that.\n        await parseSlideSection(value, beingCollectedText);\n      }\n    }\n    // Finally, return the collected text.\n    return beingCollectedText;\n  }\n};","map":{"version":3,"names":["unzip","parseStringPromise","xmlToJson","encoding","PptExtractor","constructor","decoder","TextDecoder","mimes","apply","input","files","unzipBuffer","slides","file","buffer","content","contents","decode","slide","lines","parseSlideSection","push","join","formattedText","zipBuffer","Uint8Array","ppt","Promise","resolve","reject","error","result","Object","keys","filter","name","test","map","slideSection","collectedText","beingCollectedText","Array","isArray","element","property","value"],"sources":["D:/LangChainJS/chatpdf/node_modules/office-text-extractor/build/parsers/ppt.js"],"sourcesContent":["// source/parsers/ppt.ts\n// The text extracter for MS PowerPoint files.\nimport { unzip } from 'fflate';\nimport { parseStringPromise as xmlToJson } from 'xml2js';\nimport encoding from 'text-encoding';\nexport class PptExtractor {\n    constructor() {\n        this.decoder = new encoding.TextDecoder();\n        /**\n         * The type(s) of input acceptable to this method.\n         */\n        this.mimes = [\n            'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n        ];\n        /**\n         * Extract text from a PPT file if possible.\n         *\n         * @param payload The input and its type.\n         * @returns The text extracted from the input.\n         */\n        this.apply = async (input) => {\n            const files = await unzipBuffer(input);\n            const slides = [];\n            for (const file of files) {\n                const { buffer } = file.content;\n                const contents = this.decoder.decode(buffer);\n                const slide = await xmlToJson(contents);\n                const lines = await parseSlideSection(slide);\n                slides.push(lines?.join('\\n'));\n            }\n            const formattedText = slides.join('\\n---\\n') + '\\n';\n            return formattedText;\n        };\n    }\n}\n/**\n * Unzip a PPT file, and return a list of slides.\n *\n * @param buffer The buffer containing the file.\n * @returns The slide files.\n */\nconst unzipBuffer = async (input) => {\n    // Convert the buffer to a uint-8 array, and pass it to the unzip function.\n    const zipBuffer = new Uint8Array(input.buffer);\n    const ppt = (await new Promise((resolve, reject) => {\n        unzip(zipBuffer, (error, result) => {\n            if (error)\n                reject(error);\n            else\n                resolve(result);\n        });\n    }));\n    // Filter out the files that don't contain the text on the slides.\n    const files = Object.keys(ppt)\n        .filter((name) => /ppt\\/slides\\/slide\\d*.xml/.test(name))\n        .map((name) => {\n        return { name, content: ppt[name] };\n    });\n    return files;\n};\n/**\n * Extracts text from a section of the slide, recursively.\n *\n * @param slideSection The section of the slide, converted to JSON from XML.\n * @param collectedText The lines of text parsed from the slide so far.\n *\n * @returns The lines of text on the slide.\n */\nconst parseSlideSection = async (slideSection, collectedText) => {\n    // Keep track of the text being collected.\n    const beingCollectedText = collectedText ?? [];\n    // Parse the section according to what type it is.\n    if (Array.isArray(slideSection)) {\n        // If it is, loop through the elements of the array.\n        for (const element of slideSection) {\n            // Collect all the pieces of text from the array.\n            if (typeof element === 'string' && element !== '') {\n                beingCollectedText.push(element);\n            }\n            else {\n                // However, if it is an object or another array, call this function\n                // again to parse that.\n                await parseSlideSection(element, beingCollectedText);\n            }\n        }\n        // Finally, return the collected text.\n        return beingCollectedText;\n    }\n    // If the section is an object, loop through its properties.\n    if (typeof slideSection === 'object') {\n        for (const property of Object.keys(slideSection)) {\n            // Get the value of the property.\n            const value = slideSection[property];\n            // The `pptx` format stores the actual text inside the `a:t` or `_`\n            // properties, so extract text from those properties.\n            // Check if it is a string or array that contains a string. If it is\n            // either, then collect the text content.\n            if (typeof value === 'string') {\n                if ((property === 'a:t' || property === '_') && value !== '') {\n                    beingCollectedText.push(value);\n                }\n            }\n            else if (typeof value[0] === 'string') {\n                if ((property === 'a:t' || property === '_') && value[0] !== '') {\n                    beingCollectedText.push(value[0]);\n                }\n            }\n            else {\n                // However, if it is an object or another array, call this function\n                // again to parse that.\n                await parseSlideSection(value, beingCollectedText);\n            }\n        }\n        // Finally, return the collected text.\n        return beingCollectedText;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}