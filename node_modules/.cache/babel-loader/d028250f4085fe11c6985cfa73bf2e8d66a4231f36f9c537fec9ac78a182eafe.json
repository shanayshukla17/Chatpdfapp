{"ast":null,"code":"'use strict';\n\n// See https://github.com/facebook/jest/issues/2549\n// eslint-disable-next-line node/prefer-global/url\nconst {\n  URL\n} = require('url');\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\nconst delayAsyncDestroy = require('./utils/delay-async-destroy.js');\nconst kCurrentStreamCount = Symbol('currentStreamCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst kLength = Symbol('length');\nconst nameKeys = [\n// Not an Agent option actually\n'createConnection',\n// `http2.connect()` options\n'maxDeflateDynamicTableSize', 'maxSettings', 'maxSessionMemory', 'maxHeaderListPairs', 'maxOutstandingPings', 'maxReservedRemoteStreams', 'maxSendHeaderBlockLength', 'paddingStrategy', 'peerMaxConcurrentStreams', 'settings',\n// `tls.connect()` source options\n'family', 'localAddress', 'rejectUnauthorized',\n// `tls.connect()` secure context options\n'pskCallback', 'minDHSize',\n// `tls.connect()` destination options\n// - `servername` is automatically validated, skip it\n// - `host` and `port` just describe the destination server,\n'path', 'socket',\n// `tls.createSecureContext()` options\n'ca', 'cert', 'sigalgs', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'honorCipherOrder', 'key', 'privateKeyEngine', 'privateKeyIdentifier', 'maxVersion', 'minVersion', 'pfx', 'secureOptions', 'secureProtocol', 'sessionIdContext', 'ticketKeys'];\nconst getSortedIndex = (array, value, compare) => {\n  let low = 0;\n  let high = array.length;\n  while (low < high) {\n    const mid = low + high >>> 1;\n    if (compare(array[mid], value)) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n};\nconst compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n  // Clients SHOULD NOT emit new requests on any connection whose Origin\n  // Set is a proper subset of another connection's Origin Set, and they\n  // SHOULD close it once all outstanding requests are satisfied.\n  for (let index = 0; index < where.length; index++) {\n    const coveredSession = where[index];\n    if (\n    // Unfortunately `.every()` returns true for an empty array\n    coveredSession[kOriginSet].length > 0\n\n    // The set is a proper subset when its length is less than the other set.\n    && coveredSession[kOriginSet].length < session[kOriginSet].length\n\n    // And the other set includes all elements of the subset.\n    && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))\n\n    // Makes sure that the session can handle all requests from the covered session.\n    && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {\n      // This allows pending requests to finish and prevents making new requests.\n      gracefullyClose(coveredSession);\n    }\n  }\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n  for (let index = 0; index < where.length; index++) {\n    const session = where[index];\n    if (coveredSession[kOriginSet].length > 0 && coveredSession[kOriginSet].length < session[kOriginSet].length && coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) && coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount] <= session.remoteSettings.maxConcurrentStreams) {\n      gracefullyClose(coveredSession);\n      return true;\n    }\n  }\n  return false;\n};\nconst gracefullyClose = session => {\n  session[kGracefullyClosing] = true;\n  if (session[kCurrentStreamCount] === 0) {\n    session.close();\n  }\n};\nclass Agent extends EventEmitter {\n  constructor({\n    timeout = 0,\n    maxSessions = Number.POSITIVE_INFINITY,\n    maxEmptySessions = 10,\n    maxCachedTlsSessions = 100\n  } = {}) {\n    super();\n\n    // SESSIONS[NORMALIZED_OPTIONS] = [];\n    this.sessions = {};\n\n    // The queue for creating new sessions. It looks like this:\n    // QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n    //\n    // It's faster when there are many origins. If there's only one, then QUEUE[`${options}:${origin}`] is faster.\n    // I guess object creation / deletion is causing the slowdown.\n    //\n    // The entry function has `listeners`, `completed` and `destroyed` properties.\n    // `listeners` is an array of objects containing `resolve` and `reject` functions.\n    // `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n    // `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n    this.queue = {};\n\n    // Each session will use this timeout value.\n    this.timeout = timeout;\n\n    // Max sessions in total\n    this.maxSessions = maxSessions;\n\n    // Max empty sessions in total\n    this.maxEmptySessions = maxEmptySessions;\n    this._emptySessionCount = 0;\n    this._sessionCount = 0;\n\n    // We don't support push streams by default.\n    this.settings = {\n      enablePush: false,\n      initialWindowSize: 1024 * 1024 * 32 // 32MB, see https://github.com/nodejs/node/issues/38426\n    };\n\n    // Reusing TLS sessions increases performance.\n    this.tlsSessionCache = new QuickLRU({\n      maxSize: maxCachedTlsSessions\n    });\n  }\n  get protocol() {\n    return 'https:';\n  }\n  normalizeOptions(options) {\n    let normalized = '';\n    for (let index = 0; index < nameKeys.length; index++) {\n      const key = nameKeys[index];\n      normalized += ':';\n      if (options && options[key] !== undefined) {\n        normalized += options[key];\n      }\n    }\n    return normalized;\n  }\n  _processQueue() {\n    if (this._sessionCount >= this.maxSessions) {\n      this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);\n      return;\n    }\n\n    // eslint-disable-next-line guard-for-in\n    for (const normalizedOptions in this.queue) {\n      // eslint-disable-next-line guard-for-in\n      for (const normalizedOrigin in this.queue[normalizedOptions]) {\n        const item = this.queue[normalizedOptions][normalizedOrigin];\n\n        // The entry function can be run only once.\n        if (!item.completed) {\n          item.completed = true;\n          item();\n        }\n      }\n    }\n  }\n  _isBetterSession(thisStreamCount, thatStreamCount) {\n    return thisStreamCount > thatStreamCount;\n  }\n  _accept(session, listeners, normalizedOrigin, options) {\n    let index = 0;\n    while (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {\n      // We assume `resolve(...)` calls `request(...)` *directly*,\n      // otherwise the session will get overloaded.\n      listeners[index].resolve(session);\n      index++;\n    }\n    listeners.splice(0, index);\n    if (listeners.length > 0) {\n      this.getSession(normalizedOrigin, options, listeners);\n      listeners.length = 0;\n    }\n  }\n  getSession(origin, options, listeners) {\n    return new Promise((resolve, reject) => {\n      if (Array.isArray(listeners) && listeners.length > 0) {\n        listeners = [...listeners];\n\n        // Resolve the current promise ASAP, we're just moving the listeners.\n        // They will be executed at a different time.\n        resolve();\n      } else {\n        listeners = [{\n          resolve,\n          reject\n        }];\n      }\n      try {\n        // Parse origin\n        if (typeof origin === 'string') {\n          origin = new URL(origin);\n        } else if (!(origin instanceof URL)) {\n          throw new TypeError('The `origin` argument needs to be a string or an URL object');\n        }\n        if (options) {\n          // Validate servername\n          const {\n            servername\n          } = options;\n          const {\n            hostname\n          } = origin;\n          if (servername && hostname !== servername) {\n            throw new Error(`Origin ${hostname} differs from servername ${servername}`);\n          }\n        }\n      } catch (error) {\n        for (let index = 0; index < listeners.length; index++) {\n          listeners[index].reject(error);\n        }\n        return;\n      }\n      const normalizedOptions = this.normalizeOptions(options);\n      const normalizedOrigin = origin.origin;\n      if (normalizedOptions in this.sessions) {\n        const sessions = this.sessions[normalizedOptions];\n        let maxConcurrentStreams = -1;\n        let currentStreamsCount = -1;\n        let optimalSession;\n\n        // We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n        // Additionally, we are looking for session which has biggest current pending streams count.\n        //\n        // |------------| |------------| |------------| |------------|\n        // | Session: A | | Session: B | | Session: C | | Session: D |\n        // | Pending: 5 |-| Pending: 8 |-| Pending: 9 |-| Pending: 4 |\n        // | Max:    10 | | Max:    10 | | Max:     9 | | Max:     5 |\n        // |------------| |------------| |------------| |------------|\n        //                     ^\n        //                     |\n        //     pick this one  --\n        //\n        for (let index = 0; index < sessions.length; index++) {\n          const session = sessions[index];\n          const sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n          if (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n            break;\n          }\n          if (!session[kOriginSet].includes(normalizedOrigin)) {\n            continue;\n          }\n          const sessionCurrentStreamsCount = session[kCurrentStreamCount];\n          if (sessionCurrentStreamsCount >= sessionMaxConcurrentStreams || session[kGracefullyClosing]\n          // Unfortunately the `close` event isn't called immediately,\n          // so `session.destroyed` is `true`, but `session.closed` is `false`.\n          || session.destroyed) {\n            continue;\n          }\n\n          // We only need set this once.\n          if (!optimalSession) {\n            maxConcurrentStreams = sessionMaxConcurrentStreams;\n          }\n\n          // Either get the session which has biggest current stream count or the lowest.\n          if (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {\n            optimalSession = session;\n            currentStreamsCount = sessionCurrentStreamsCount;\n          }\n        }\n        if (optimalSession) {\n          this._accept(optimalSession, listeners, normalizedOrigin, options);\n          return;\n        }\n      }\n      if (normalizedOptions in this.queue) {\n        if (normalizedOrigin in this.queue[normalizedOptions]) {\n          // There's already an item in the queue, just attach ourselves to it.\n          this.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n          return;\n        }\n      } else {\n        this.queue[normalizedOptions] = {\n          [kLength]: 0\n        };\n      }\n\n      // The entry must be removed from the queue IMMEDIATELY when:\n      // 1. the session connects successfully,\n      // 2. an error occurs.\n      const removeFromQueue = () => {\n        // Our entry can be replaced. We cannot remove the new one.\n        if (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n          delete this.queue[normalizedOptions][normalizedOrigin];\n          if (--this.queue[normalizedOptions][kLength] === 0) {\n            delete this.queue[normalizedOptions];\n          }\n        }\n      };\n\n      // The main logic is here\n      const entry = async () => {\n        this._sessionCount++;\n        const name = `${normalizedOrigin}:${normalizedOptions}`;\n        let receivedSettings = false;\n        let socket;\n        try {\n          const computedOptions = {\n            ...options\n          };\n          if (computedOptions.settings === undefined) {\n            computedOptions.settings = this.settings;\n          }\n          if (computedOptions.session === undefined) {\n            computedOptions.session = this.tlsSessionCache.get(name);\n          }\n          const createConnection = computedOptions.createConnection || this.createConnection;\n\n          // A hacky workaround to enable async `createConnection`\n          socket = await createConnection.call(this, origin, computedOptions);\n          computedOptions.createConnection = () => socket;\n          const session = http2.connect(origin, computedOptions);\n          session[kCurrentStreamCount] = 0;\n          session[kGracefullyClosing] = false;\n\n          // Node.js return https://false:443 instead of https://1.1.1.1:443\n          const getOriginSet = () => {\n            const {\n              socket\n            } = session;\n            let originSet;\n            if (socket.servername === false) {\n              socket.servername = socket.remoteAddress;\n              originSet = session.originSet;\n              socket.servername = false;\n            } else {\n              originSet = session.originSet;\n            }\n            return originSet;\n          };\n          const isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;\n          session.socket.once('session', tlsSession => {\n            this.tlsSessionCache.set(name, tlsSession);\n          });\n          session.once('error', error => {\n            // Listeners are empty when the session successfully connected.\n            for (let index = 0; index < listeners.length; index++) {\n              listeners[index].reject(error);\n            }\n\n            // The connection got broken, purge the cache.\n            this.tlsSessionCache.delete(name);\n          });\n          session.setTimeout(this.timeout, () => {\n            // Terminates all streams owned by this session.\n            session.destroy();\n          });\n          session.once('close', () => {\n            this._sessionCount--;\n            if (receivedSettings) {\n              // Assumes session `close` is emitted after request `close`\n              this._emptySessionCount--;\n\n              // This cannot be moved to the stream logic,\n              // because there may be a session that hadn't made a single request.\n              const where = this.sessions[normalizedOptions];\n              if (where.length === 1) {\n                delete this.sessions[normalizedOptions];\n              } else {\n                where.splice(where.indexOf(session), 1);\n              }\n            } else {\n              // Broken connection\n              removeFromQueue();\n              const error = new Error('Session closed without receiving a SETTINGS frame');\n              error.code = 'HTTP2WRAPPER_NOSETTINGS';\n              for (let index = 0; index < listeners.length; index++) {\n                listeners[index].reject(error);\n              }\n            }\n\n            // There may be another session awaiting.\n            this._processQueue();\n          });\n\n          // Iterates over the queue and processes listeners.\n          const processListeners = () => {\n            const queue = this.queue[normalizedOptions];\n            if (!queue) {\n              return;\n            }\n            const originSet = session[kOriginSet];\n            for (let index = 0; index < originSet.length; index++) {\n              const origin = originSet[index];\n              if (origin in queue) {\n                const {\n                  listeners,\n                  completed\n                } = queue[origin];\n                let index = 0;\n\n                // Prevents session overloading.\n                while (index < listeners.length && isFree()) {\n                  // We assume `resolve(...)` calls `request(...)` *directly*,\n                  // otherwise the session will get overloaded.\n                  listeners[index].resolve(session);\n                  index++;\n                }\n                queue[origin].listeners.splice(0, index);\n                if (queue[origin].listeners.length === 0 && !completed) {\n                  delete queue[origin];\n                  if (--queue[kLength] === 0) {\n                    delete this.queue[normalizedOptions];\n                    break;\n                  }\n                }\n\n                // We're no longer free, no point in continuing.\n                if (!isFree()) {\n                  break;\n                }\n              }\n            }\n          };\n\n          // The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n          session.on('origin', () => {\n            session[kOriginSet] = getOriginSet() || [];\n            session[kGracefullyClosing] = false;\n            closeSessionIfCovered(this.sessions[normalizedOptions], session);\n            if (session[kGracefullyClosing] || !isFree()) {\n              return;\n            }\n            processListeners();\n            if (!isFree()) {\n              return;\n            }\n\n            // Close covered sessions (if possible).\n            closeCoveredSessions(this.sessions[normalizedOptions], session);\n          });\n          session.once('remoteSettings', () => {\n            // The Agent could have been destroyed already.\n            if (entry.destroyed) {\n              const error = new Error('Agent has been destroyed');\n              for (let index = 0; index < listeners.length; index++) {\n                listeners[index].reject(error);\n              }\n              session.destroy();\n              return;\n            }\n\n            // See https://github.com/nodejs/node/issues/38426\n            if (session.setLocalWindowSize) {\n              session.setLocalWindowSize(1024 * 1024 * 4); // 4 MB\n            }\n            session[kOriginSet] = getOriginSet() || [];\n            if (session.socket.encrypted) {\n              const mainOrigin = session[kOriginSet][0];\n              if (mainOrigin !== normalizedOrigin) {\n                const error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);\n                for (let index = 0; index < listeners.length; index++) {\n                  listeners[index].reject(error);\n                }\n                session.destroy();\n                return;\n              }\n            }\n            removeFromQueue();\n            {\n              const where = this.sessions;\n              if (normalizedOptions in where) {\n                const sessions = where[normalizedOptions];\n                sessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n              } else {\n                where[normalizedOptions] = [session];\n              }\n            }\n            receivedSettings = true;\n            this._emptySessionCount++;\n            this.emit('session', session);\n            this._accept(session, listeners, normalizedOrigin, options);\n            if (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {\n              this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);\n            }\n\n            // `session.remoteSettings.maxConcurrentStreams` might get increased\n            session.on('remoteSettings', () => {\n              if (!isFree()) {\n                return;\n              }\n              processListeners();\n              if (!isFree()) {\n                return;\n              }\n\n              // In case the Origin Set changes\n              closeCoveredSessions(this.sessions[normalizedOptions], session);\n            });\n          });\n\n          // Shim `session.request()` in order to catch all streams\n          session[kRequest] = session.request;\n          session.request = (headers, streamOptions) => {\n            if (session[kGracefullyClosing]) {\n              throw new Error('The session is gracefully closing. No new streams are allowed.');\n            }\n            const stream = session[kRequest](headers, streamOptions);\n\n            // The process won't exit until the session is closed or all requests are gone.\n            session.ref();\n            if (session[kCurrentStreamCount]++ === 0) {\n              this._emptySessionCount--;\n            }\n            stream.once('close', () => {\n              if (--session[kCurrentStreamCount] === 0) {\n                this._emptySessionCount++;\n                session.unref();\n                if (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {\n                  session.close();\n                  return;\n                }\n              }\n              if (session.destroyed || session.closed) {\n                return;\n              }\n              if (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {\n                closeCoveredSessions(this.sessions[normalizedOptions], session);\n                processListeners();\n                if (session[kCurrentStreamCount] === 0) {\n                  this._processQueue();\n                }\n              }\n            });\n            return stream;\n          };\n        } catch (error) {\n          removeFromQueue();\n          this._sessionCount--;\n          for (let index = 0; index < listeners.length; index++) {\n            listeners[index].reject(error);\n          }\n        }\n      };\n      entry.listeners = listeners;\n      entry.completed = false;\n      entry.destroyed = false;\n      this.queue[normalizedOptions][normalizedOrigin] = entry;\n      this.queue[normalizedOptions][kLength]++;\n      this._processQueue();\n    });\n  }\n  request(origin, options, headers, streamOptions) {\n    return new Promise((resolve, reject) => {\n      this.getSession(origin, options, [{\n        reject,\n        resolve: session => {\n          try {\n            const stream = session.request(headers, streamOptions);\n\n            // Do not throw before `request(...)` has been awaited\n            delayAsyncDestroy(stream);\n            resolve(stream);\n          } catch (error) {\n            reject(error);\n          }\n        }\n      }]);\n    });\n  }\n  async createConnection(origin, options) {\n    return Agent.connect(origin, options);\n  }\n  static connect(origin, options) {\n    options.ALPNProtocols = ['h2'];\n    const port = origin.port || 443;\n    const host = origin.hostname;\n    if (typeof options.servername === 'undefined') {\n      options.servername = host;\n    }\n    const socket = tls.connect(port, host, options);\n    if (options.socket) {\n      socket._peername = {\n        family: undefined,\n        address: undefined,\n        port\n      };\n    }\n    return socket;\n  }\n  closeEmptySessions(maxCount = Number.POSITIVE_INFINITY) {\n    let closedCount = 0;\n    const {\n      sessions\n    } = this;\n\n    // eslint-disable-next-line guard-for-in\n    for (const key in sessions) {\n      const thisSessions = sessions[key];\n      for (let index = 0; index < thisSessions.length; index++) {\n        const session = thisSessions[index];\n        if (session[kCurrentStreamCount] === 0) {\n          closedCount++;\n          session.close();\n          if (closedCount >= maxCount) {\n            return closedCount;\n          }\n        }\n      }\n    }\n    return closedCount;\n  }\n  destroy(reason) {\n    const {\n      sessions,\n      queue\n    } = this;\n\n    // eslint-disable-next-line guard-for-in\n    for (const key in sessions) {\n      const thisSessions = sessions[key];\n      for (let index = 0; index < thisSessions.length; index++) {\n        thisSessions[index].destroy(reason);\n      }\n    }\n\n    // eslint-disable-next-line guard-for-in\n    for (const normalizedOptions in queue) {\n      const entries = queue[normalizedOptions];\n\n      // eslint-disable-next-line guard-for-in\n      for (const normalizedOrigin in entries) {\n        entries[normalizedOrigin].destroyed = true;\n      }\n    }\n\n    // New requests should NOT attach to destroyed sessions\n    this.queue = {};\n    this.tlsSessionCache.clear();\n  }\n  get emptySessionCount() {\n    return this._emptySessionCount;\n  }\n  get pendingSessionCount() {\n    return this._sessionCount - this._emptySessionCount;\n  }\n  get sessionCount() {\n    return this._sessionCount;\n  }\n}\nAgent.kCurrentStreamCount = kCurrentStreamCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\nmodule.exports = {\n  Agent,\n  globalAgent: new Agent()\n};","map":{"version":3,"names":["URL","require","EventEmitter","tls","http2","QuickLRU","delayAsyncDestroy","kCurrentStreamCount","Symbol","kRequest","kOriginSet","kGracefullyClosing","kLength","nameKeys","getSortedIndex","array","value","compare","low","high","length","mid","compareSessions","a","b","remoteSettings","maxConcurrentStreams","closeCoveredSessions","where","session","index","coveredSession","every","origin","includes","gracefullyClose","closeSessionIfCovered","close","Agent","constructor","timeout","maxSessions","Number","POSITIVE_INFINITY","maxEmptySessions","maxCachedTlsSessions","sessions","queue","_emptySessionCount","_sessionCount","settings","enablePush","initialWindowSize","tlsSessionCache","maxSize","protocol","normalizeOptions","options","normalized","key","undefined","_processQueue","closeEmptySessions","normalizedOptions","normalizedOrigin","item","completed","_isBetterSession","thisStreamCount","thatStreamCount","_accept","listeners","resolve","splice","getSession","Promise","reject","Array","isArray","TypeError","servername","hostname","Error","error","currentStreamsCount","optimalSession","sessionMaxConcurrentStreams","sessionCurrentStreamsCount","destroyed","push","removeFromQueue","entry","name","receivedSettings","socket","computedOptions","get","createConnection","call","connect","getOriginSet","originSet","remoteAddress","isFree","once","tlsSession","set","delete","setTimeout","destroy","indexOf","code","processListeners","on","setLocalWindowSize","encrypted","mainOrigin","emit","request","headers","streamOptions","stream","ref","unref","closed","ALPNProtocols","port","host","_peername","family","address","maxCount","closedCount","thisSessions","reason","entries","clear","emptySessionCount","pendingSessionCount","sessionCount","module","exports","globalAgent"],"sources":["D:/LangChainJS/chatpdf/node_modules/http2-wrapper/source/agent.js"],"sourcesContent":["'use strict';\n// See https://github.com/facebook/jest/issues/2549\n// eslint-disable-next-line node/prefer-global/url\nconst {URL} = require('url');\nconst EventEmitter = require('events');\nconst tls = require('tls');\nconst http2 = require('http2');\nconst QuickLRU = require('quick-lru');\nconst delayAsyncDestroy = require('./utils/delay-async-destroy.js');\n\nconst kCurrentStreamCount = Symbol('currentStreamCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\nconst kLength = Symbol('length');\n\nconst nameKeys = [\n\t// Not an Agent option actually\n\t'createConnection',\n\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSettings',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\t'peerMaxConcurrentStreams',\n\t'settings',\n\n\t// `tls.connect()` source options\n\t'family',\n\t'localAddress',\n\t'rejectUnauthorized',\n\n\t// `tls.connect()` secure context options\n\t'pskCallback',\n\t'minDHSize',\n\n\t// `tls.connect()` destination options\n\t// - `servername` is automatically validated, skip it\n\t// - `host` and `port` just describe the destination server,\n\t'path',\n\t'socket',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'sigalgs',\n\t'ciphers',\n\t'clientCertEngine',\n\t'crl',\n\t'dhparam',\n\t'ecdhCurve',\n\t'honorCipherOrder',\n\t'key',\n\t'privateKeyEngine',\n\t'privateKeyIdentifier',\n\t'maxVersion',\n\t'minVersion',\n\t'pfx',\n\t'secureOptions',\n\t'secureProtocol',\n\t'sessionIdContext',\n\t'ticketKeys'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\tif (compare(array[mid], value)) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (let index = 0; index < where.length; index++) {\n\t\tconst coveredSession = where[index];\n\n\t\tif (\n\t\t\t// Unfortunately `.every()` returns true for an empty array\n\t\t\tcoveredSession[kOriginSet].length > 0\n\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\t&& coveredSession[kOriginSet].length < session[kOriginSet].length\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\t&& coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\t&& (coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount]) <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (let index = 0; index < where.length; index++) {\n\t\tconst session = where[index];\n\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length > 0\n\t\t\t&& coveredSession[kOriginSet].length < session[kOriginSet].length\n\t\t\t&& coveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin))\n\t\t\t&& (coveredSession[kCurrentStreamCount] + session[kCurrentStreamCount]) <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 0, maxSessions = Number.POSITIVE_INFINITY, maxEmptySessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// It's faster when there are many origins. If there's only one, then QUEUE[`${options}:${origin}`] is faster.\n\t\t// I guess object creation / deletion is causing the slowdown.\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max empty sessions in total\n\t\tthis.maxEmptySessions = maxEmptySessions;\n\n\t\tthis._emptySessionCount = 0;\n\t\tthis._sessionCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false,\n\t\t\tinitialWindowSize: 1024 * 1024 * 32 // 32MB, see https://github.com/nodejs/node/issues/38426\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tget protocol() {\n\t\treturn 'https:';\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tfor (let index = 0; index < nameKeys.length; index++) {\n\t\t\tconst key = nameKeys[index];\n\n\t\t\tnormalized += ':';\n\n\t\t\tif (options && options[key] !== undefined) {\n\t\t\t\tnormalized += options[key];\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_processQueue() {\n\t\tif (this._sessionCount >= this.maxSessions) {\n\t\t\tthis.closeEmptySessions(this.maxSessions - this._sessionCount + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const normalizedOptions in this.queue) {\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (const normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t// The entry function can be run only once.\n\t\t\t\tif (!item.completed) {\n\t\t\t\t\titem.completed = true;\n\n\t\t\t\t\titem();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_isBetterSession(thisStreamCount, thatStreamCount) {\n\t\treturn thisStreamCount > thatStreamCount;\n\t}\n\n\t_accept(session, listeners, normalizedOrigin, options) {\n\t\tlet index = 0;\n\n\t\twhile (index < listeners.length && session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams) {\n\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t// otherwise the session will get overloaded.\n\t\t\tlisteners[index].resolve(session);\n\n\t\t\tindex++;\n\t\t}\n\n\t\tlisteners.splice(0, index);\n\n\t\tif (listeners.length > 0) {\n\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\tlisteners.length = 0;\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners) && listeners.length > 0) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// Parse origin\n\t\t\t\tif (typeof origin === 'string') {\n\t\t\t\t\torigin = new URL(origin);\n\t\t\t\t} else if (!(origin instanceof URL)) {\n\t\t\t\t\tthrow new TypeError('The `origin` argument needs to be a string or an URL object');\n\t\t\t\t}\n\n\t\t\t\tif (options) {\n\t\t\t\t\t// Validate servername\n\t\t\t\t\tconst {servername} = options;\n\t\t\t\t\tconst {hostname} = origin;\n\t\t\t\t\tif (servername && hostname !== servername) {\n\t\t\t\t\t\tthrow new Error(`Origin ${hostname} differs from servername ${servername}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = origin.origin;\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\t//\n\t\t\t\t// |------------| |------------| |------------| |------------|\n\t\t\t\t// | Session: A | | Session: B | | Session: C | | Session: D |\n\t\t\t\t// | Pending: 5 |-| Pending: 8 |-| Pending: 9 |-| Pending: 4 |\n\t\t\t\t// | Max:    10 | | Max:    10 | | Max:     9 | | Max:     5 |\n\t\t\t\t// |------------| |------------| |------------| |------------|\n\t\t\t\t//                     ^\n\t\t\t\t//                     |\n\t\t\t\t//     pick this one  --\n\t\t\t\t//\n\t\t\t\tfor (let index = 0; index < sessions.length; index++) {\n\t\t\t\t\tconst session = sessions[index];\n\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamCount];\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams\n\t\t\t\t\t\t|| session[kGracefullyClosing]\n\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t|| session.destroyed\n\t\t\t\t\t) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// We only need set this once.\n\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Either get the session which has biggest current stream count or the lowest.\n\t\t\t\t\tif (this._isBetterSession(sessionCurrentStreamsCount, currentStreamsCount)) {\n\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\tthis._accept(optimalSession, listeners, normalizedOrigin, options);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {\n\t\t\t\t\t[kLength]: 0\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (--this.queue[normalizedOptions][kLength] === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = async () => {\n\t\t\t\tthis._sessionCount++;\n\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\t\t\t\tlet socket;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst computedOptions = {...options};\n\n\t\t\t\t\tif (computedOptions.settings === undefined) {\n\t\t\t\t\t\tcomputedOptions.settings = this.settings;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (computedOptions.session === undefined) {\n\t\t\t\t\t\tcomputedOptions.session = this.tlsSessionCache.get(name);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst createConnection = computedOptions.createConnection || this.createConnection;\n\n\t\t\t\t\t// A hacky workaround to enable async `createConnection`\n\t\t\t\t\tsocket = await createConnection.call(this, origin, computedOptions);\n\t\t\t\t\tcomputedOptions.createConnection = () => socket;\n\n\t\t\t\t\tconst session = http2.connect(origin, computedOptions);\n\t\t\t\t\tsession[kCurrentStreamCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\t// Node.js return https://false:443 instead of https://1.1.1.1:443\n\t\t\t\t\tconst getOriginSet = () => {\n\t\t\t\t\t\tconst {socket} = session;\n\n\t\t\t\t\t\tlet originSet;\n\t\t\t\t\t\tif (socket.servername === false) {\n\t\t\t\t\t\t\tsocket.servername = socket.remoteAddress;\n\t\t\t\t\t\t\toriginSet = session.originSet;\n\t\t\t\t\t\t\tsocket.servername = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toriginSet = session.originSet;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn originSet;\n\t\t\t\t\t};\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tthis._sessionCount--;\n\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// Assumes session `close` is emitted after request `close`\n\t\t\t\t\t\t\tthis._emptySessionCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\n\t\t\t\t\t\t\tif (where.length === 1) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._processQueue();\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tconst queue = this.queue[normalizedOptions];\n\t\t\t\t\t\tif (!queue) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst originSet = session[kOriginSet];\n\n\t\t\t\t\t\tfor (let index = 0; index < originSet.length; index++) {\n\t\t\t\t\t\t\tconst origin = originSet[index];\n\n\t\t\t\t\t\t\tif (origin in queue) {\n\t\t\t\t\t\t\t\tconst {listeners, completed} = queue[origin];\n\n\t\t\t\t\t\t\t\tlet index = 0;\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (index < listeners.length && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners[index].resolve(session);\n\n\t\t\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tqueue[origin].listeners.splice(0, index);\n\n\t\t\t\t\t\t\t\tif (queue[origin].listeners.length === 0 && !completed) {\n\t\t\t\t\t\t\t\t\tdelete queue[origin];\n\n\t\t\t\t\t\t\t\t\tif (--queue[kLength] === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = getOriginSet() || [];\n\t\t\t\t\t\tsession[kGracefullyClosing] = false;\n\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\tif (session[kGracefullyClosing] || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// See https://github.com/nodejs/node/issues/38426\n\t\t\t\t\t\tif (session.setLocalWindowSize) {\n\t\t\t\t\t\t\tsession.setLocalWindowSize(1024 * 1024 * 4); // 4 MB\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = getOriginSet() || [];\n\n\t\t\t\t\t\tif (session.socket.encrypted) {\n\t\t\t\t\t\t\tconst mainOrigin = session[kOriginSet][0];\n\t\t\t\t\t\t\tif (mainOrigin !== normalizedOrigin) {\n\t\t\t\t\t\t\t\tconst error = new Error(`Requested origin ${normalizedOrigin} does not match server ${mainOrigin}`);\n\n\t\t\t\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treceivedSettings = true;\n\t\t\t\t\t\tthis._emptySessionCount++;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\t\t\t\t\t\tthis._accept(session, listeners, normalizedOrigin, options);\n\n\t\t\t\t\t\tif (session[kCurrentStreamCount] === 0 && this._emptySessionCount > this.maxEmptySessions) {\n\t\t\t\t\t\t\tthis.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\tif (session[kCurrentStreamCount]++ === 0) {\n\t\t\t\t\t\t\tthis._emptySessionCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\tif (--session[kCurrentStreamCount] === 0) {\n\t\t\t\t\t\t\t\tthis._emptySessionCount++;\n\t\t\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\t\t\tif (this._emptySessionCount > this.maxEmptySessions || session[kGracefullyClosing]) {\n\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (session.destroyed || session.closed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (isFree() && !closeSessionIfCovered(this.sessions[normalizedOptions], session)) {\n\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t\tif (session[kCurrentStreamCount] === 0) {\n\t\t\t\t\t\t\t\t\tthis._processQueue();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\tthis._sessionCount--;\n\n\t\t\t\t\tfor (let index = 0; index < listeners.length; index++) {\n\t\t\t\t\t\tlisteners[index].reject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis.queue[normalizedOptions][kLength]++;\n\t\t\tthis._processQueue();\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst stream = session.request(headers, streamOptions);\n\n\t\t\t\t\t\t// Do not throw before `request(...)` has been awaited\n\t\t\t\t\t\tdelayAsyncDestroy(stream);\n\n\t\t\t\t\t\tresolve(stream);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tasync createConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\tconst socket = tls.connect(port, host, options);\n\n\t\tif (options.socket) {\n\t\t\tsocket._peername = {\n\t\t\t\tfamily: undefined,\n\t\t\t\taddress: undefined,\n\t\t\t\tport\n\t\t\t};\n\t\t}\n\n\t\treturn socket;\n\t}\n\n\tcloseEmptySessions(maxCount = Number.POSITIVE_INFINITY) {\n\t\tlet closedCount = 0;\n\n\t\tconst {sessions} = this;\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const key in sessions) {\n\t\t\tconst thisSessions = sessions[key];\n\n\t\t\tfor (let index = 0; index < thisSessions.length; index++) {\n\t\t\t\tconst session = thisSessions[index];\n\n\t\t\t\tif (session[kCurrentStreamCount] === 0) {\n\t\t\t\t\tclosedCount++;\n\t\t\t\t\tsession.close();\n\n\t\t\t\t\tif (closedCount >= maxCount) {\n\t\t\t\t\t\treturn closedCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closedCount;\n\t}\n\n\tdestroy(reason) {\n\t\tconst {sessions, queue} = this;\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const key in sessions) {\n\t\t\tconst thisSessions = sessions[key];\n\n\t\t\tfor (let index = 0; index < thisSessions.length; index++) {\n\t\t\t\tthisSessions[index].destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\t// eslint-disable-next-line guard-for-in\n\t\tfor (const normalizedOptions in queue) {\n\t\t\tconst entries = queue[normalizedOptions];\n\n\t\t\t// eslint-disable-next-line guard-for-in\n\t\t\tfor (const normalizedOrigin in entries) {\n\t\t\t\tentries[normalizedOrigin].destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t\tthis.tlsSessionCache.clear();\n\t}\n\n\tget emptySessionCount() {\n\t\treturn this._emptySessionCount;\n\t}\n\n\tget pendingSessionCount() {\n\t\treturn this._sessionCount - this._emptySessionCount;\n\t}\n\n\tget sessionCount() {\n\t\treturn this._sessionCount;\n\t}\n}\n\nAgent.kCurrentStreamCount = kCurrentStreamCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}