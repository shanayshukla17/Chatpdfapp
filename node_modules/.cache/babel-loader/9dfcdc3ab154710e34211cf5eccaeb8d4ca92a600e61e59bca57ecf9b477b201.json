{"ast":null,"code":"import { EventEmitter } from 'node:events';\nimport is from '@sindresorhus/is';\nimport PCancelable from 'p-cancelable';\nimport { HTTPError, RetryError } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\nexport default function asPromise(firstRequest) {\n  let globalRequest;\n  let globalResponse;\n  let normalizedOptions;\n  const emitter = new EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    onCancel(() => {\n      globalRequest.destroy();\n    });\n    onCancel.shouldReject = false;\n    onCancel(() => {\n      reject(new CancelError(globalRequest));\n    });\n    const makeRequest = retryCount => {\n      // Errors when a new request is made after the promise settles.\n      // Used to detect a race condition.\n      // See https://github.com/sindresorhus/got/issues/1489\n      onCancel(() => {});\n      const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);\n      request.retryCount = retryCount;\n      request._noPipe = true;\n      globalRequest = request;\n      request.once('response', async response => {\n        // Parse body\n        const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();\n        const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n        const {\n          options\n        } = request;\n        if (isCompressed && !options.decompress) {\n          response.body = response.rawBody;\n        } else {\n          try {\n            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fall back to `utf8`\n            response.body = response.rawBody.toString();\n            if (isResponseOk(response)) {\n              request._beforeError(error);\n              return;\n            }\n          }\n        }\n        try {\n          const hooks = options.hooks.afterResponse;\n          for (const [index, hook] of hooks.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              options.merge(updatedOptions);\n              options.prefixUrl = '';\n              if (updatedOptions.url) {\n                options.url = updatedOptions.url;\n              }\n              // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n              options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n              throw new RetryError(request);\n            });\n            if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n              throw new TypeError('The `afterResponse` hook returned an invalid value');\n            }\n          }\n        } catch (error) {\n          request._beforeError(error);\n          return;\n        }\n        globalResponse = response;\n        if (!isResponseOk(response)) {\n          request._beforeError(new HTTPError(response));\n          return;\n        }\n        request.destroy();\n        resolve(request.options.resolveBodyOnly ? response.body : response);\n      });\n      const onError = error => {\n        if (promise.isCanceled) {\n          return;\n        }\n        const {\n          options\n        } = request;\n        if (error instanceof HTTPError && !options.throwHttpErrors) {\n          const {\n            response\n          } = error;\n          request.destroy();\n          resolve(request.options.resolveBodyOnly ? response.body : response);\n          return;\n        }\n        reject(error);\n      };\n      request.once('error', onError);\n      const previousBody = request.options?.body;\n      request.once('retry', (newRetryCount, error) => {\n        firstRequest = undefined;\n        const newBody = request.options.body;\n        if (previousBody === newBody && is.nodeStream(newBody)) {\n          error.message = 'Cannot retry with consumed body stream';\n          onError(error);\n          return;\n        }\n        // This is needed! We need to reuse `request.options` because they can get modified!\n        // For example, by calling `promise.json()`.\n        normalizedOptions = request.options;\n        makeRequest(newRetryCount);\n      });\n      proxyEvents(request, emitter, proxiedRequestEvents);\n      if (is.undefined(firstRequest)) {\n        void request.flush();\n      }\n    };\n    makeRequest(0);\n  });\n  promise.on = (event, fn) => {\n    emitter.on(event, fn);\n    return promise;\n  };\n  promise.off = (event, fn) => {\n    emitter.off(event, fn);\n    return promise;\n  };\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      const {\n        options\n      } = globalResponse.request;\n      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n    })();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n  promise.json = () => {\n    if (globalRequest.options) {\n      const {\n        headers\n      } = globalRequest.options;\n      if (!globalRequest.writableFinished && !('accept' in headers)) {\n        headers.accept = 'application/json';\n      }\n    }\n    return shortcut('json');\n  };\n  promise.buffer = () => shortcut('buffer');\n  promise.text = () => shortcut('text');\n  return promise;\n}","map":{"version":3,"names":["EventEmitter","is","PCancelable","HTTPError","RetryError","Request","parseBody","isResponseOk","proxyEvents","CancelError","proxiedRequestEvents","asPromise","firstRequest","globalRequest","globalResponse","normalizedOptions","emitter","promise","resolve","reject","onCancel","destroy","shouldReject","makeRequest","retryCount","request","undefined","_noPipe","once","response","contentEncoding","headers","toLowerCase","isCompressed","options","decompress","body","rawBody","responseType","parseJson","encoding","error","toString","_beforeError","hooks","afterResponse","index","hook","entries","updatedOptions","merge","prefixUrl","url","slice","object","number","statusCode","nullOrUndefined","TypeError","resolveBodyOnly","onError","isCanceled","throwHttpErrors","previousBody","newRetryCount","newBody","nodeStream","message","flush","on","event","fn","off","shortcut","newPromise","Object","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"sources":["D:/LangChainJS/chatpdf/node_modules/got/dist/source/as-promise/index.js"],"sourcesContent":["import { EventEmitter } from 'node:events';\nimport is from '@sindresorhus/is';\nimport PCancelable from 'p-cancelable';\nimport { HTTPError, RetryError, } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress',\n];\nexport default function asPromise(firstRequest) {\n    let globalRequest;\n    let globalResponse;\n    let normalizedOptions;\n    const emitter = new EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        onCancel(() => {\n            globalRequest.destroy();\n        });\n        onCancel.shouldReject = false;\n        onCancel(() => {\n            reject(new CancelError(globalRequest));\n        });\n        const makeRequest = (retryCount) => {\n            // Errors when a new request is made after the promise settles.\n            // Used to detect a race condition.\n            // See https://github.com/sindresorhus/got/issues/1489\n            onCancel(() => { });\n            const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            globalRequest = request;\n            request.once('response', async (response) => {\n                // Parse body\n                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();\n                const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = response.rawBody;\n                }\n                else {\n                    try {\n                        response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fall back to `utf8`\n                        response.body = response.rawBody.toString();\n                        if (isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    const hooks = options.hooks.afterResponse;\n                    for (const [index, hook] of hooks.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            options.merge(updatedOptions);\n                            options.prefixUrl = '';\n                            if (updatedOptions.url) {\n                                options.url = updatedOptions.url;\n                            }\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                            throw new RetryError(request);\n                        });\n                        if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n                            throw new TypeError('The `afterResponse` hook returned an invalid value');\n                        }\n                    }\n                }\n                catch (error) {\n                    request._beforeError(error);\n                    return;\n                }\n                globalResponse = response;\n                if (!isResponseOk(response)) {\n                    request._beforeError(new HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    request.destroy();\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options?.body;\n            request.once('retry', (newRetryCount, error) => {\n                firstRequest = undefined;\n                const newBody = request.options.body;\n                if (previousBody === newBody && is.nodeStream(newBody)) {\n                    error.message = 'Cannot retry with consumed body stream';\n                    onError(error);\n                    return;\n                }\n                // This is needed! We need to reuse `request.options` because they can get modified!\n                // For example, by calling `promise.json()`.\n                normalizedOptions = request.options;\n                makeRequest(newRetryCount);\n            });\n            proxyEvents(request, emitter, proxiedRequestEvents);\n            if (is.undefined(firstRequest)) {\n                void request.flush();\n            }\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    promise.off = (event, fn) => {\n        emitter.off(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (globalRequest.options) {\n            const { headers } = globalRequest.options;\n            if (!globalRequest.writableFinished && !('accept' in headers)) {\n                headers.accept = 'application/json';\n            }\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}