{"ast":null,"code":"/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n */\nvar fs = require('fs');\nvar async = require('async');\nvar rimraf = require('rimraf');\nvar util = require('util');\nvar events = require('events');\nvar split = require('./split.js');\nvar searchable = require('./searchable.js');\nvar pathhash = require('pathhash');\nfunction Electronic() {\n  if (false === this instanceof Electronic) {\n    return new Electronic();\n  }\n}\nutil.inherits(Electronic, events.EventEmitter);\nmodule.exports = Electronic;\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nElectronic.prototype.process = function (pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  var single_page_pdf_file_paths = [];\n  fs.exists(pdf_path, function (exists) {\n    var err;\n    if (!exists) {\n      err = 'no file exists at the path you specified: ' + pdf_path;\n      self.emit('error', {\n        error: err,\n        pdf_path: pdf_path\n      });\n      return;\n    }\n    pathhash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', {\n          error: err,\n          pdf_path: pdf_path\n        });\n        return;\n      }\n      // split the pdf into single page pdf files\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n        if (!output) {\n          err = 'failed to split pdf file into distinct pages';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n        split_output = output;\n        if (!split_output.hasOwnProperty('files') || split_output.files.length == 0) {\n          err = 'no pages where found in your pdf document';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        var files = split_output.files;\n        var index = 0;\n        async.forEachSeries(files,\n        // extract the text for each page\n        function (file, cb) {\n          index++;\n          searchable(file.file_path, options, function (err, extract) {\n            if (err) {\n              self.emit('error', {\n                error: err,\n                pdf_path: pdf_path\n              });\n              return;\n            }\n            text_pages.push(extract);\n            var file_path = file.file_path;\n            single_page_pdf_file_paths.push(file.file_path);\n            self.emit('page', {\n              hash: hash,\n              text: extract,\n              index: index,\n              pdf_path: pdf_path\n            });\n            cb();\n          });\n        }, function (err) {\n          if (!err) {\n            self.emit('complete', {\n              hash: hash,\n              text_pages: text_pages,\n              pdf_path: pdf_path,\n              single_page_pdf_file_paths: single_page_pdf_file_paths\n            });\n            return;\n          }\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          if (!split_output || !split_output.folder) {\n            return;\n          }\n          fs.exists(split_output.folder, function (exists) {\n            if (!exists) {\n              return;\n            }\n            var remove_cb = function () {};\n            rimraf(split_output.folder, remove_cb);\n          });\n        });\n      });\n    });\n  });\n};","map":{"version":3,"names":["fs","require","async","rimraf","util","events","split","searchable","pathhash","Electronic","inherits","EventEmitter","module","exports","prototype","process","pdf_path","options","self","text_pages","split_output","single_page_pdf_file_paths","exists","err","emit","error","hash","output","hasOwnProperty","files","length","index","forEachSeries","file","cb","file_path","extract","push","text","folder","remove_cb"],"sources":["D:/LangChainJS/chatpdf/node_modules/pdf-extract/lib/electronic.js"],"sourcesContent":["/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n */\nvar fs = require('fs');\nvar async = require('async');\n\nvar rimraf = require('rimraf');\nvar util = require('util');\nvar events = require('events');\n\nvar split = require('./split.js');\nvar searchable = require('./searchable.js');\nvar pathhash = require('pathhash');\n\n\nfunction Electronic(){\n  if(false === (this instanceof Electronic)) {\n    return new Electronic();\n  }\n}\nutil.inherits(Electronic, events.EventEmitter);\nmodule.exports = Electronic;\n\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nElectronic.prototype.process = function(pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  var single_page_pdf_file_paths = [];\n  fs.exists(pdf_path, function (exists) {\n    var err;\n    if (!exists) {\n      err = 'no file exists at the path you specified: ' + pdf_path\n      self.emit('error', { error: err, pdf_path: pdf_path});\n      return\n    }\n    pathhash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', { error: err, pdf_path: pdf_path});\n        return\n      }\n      // split the pdf into single page pdf files\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n\n\n        if (!output) {\n          err = 'failed to split pdf file into distinct pages';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        split_output = output;\n        if (!split_output.hasOwnProperty('files') || split_output.files.length == 0) {\n          err = 'no pages where found in your pdf document';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        var files = split_output.files;\n        var index = 0;\n        async.forEachSeries(\n          files,\n          // extract the text for each page\n          function (file, cb) {\n            index++;\n            searchable(file.file_path, options, function (err, extract) {\n\t          if(err){\n\t            self.emit('error', { error: err, pdf_path: pdf_path});\n\t            return;\n\t          }\n              text_pages.push(extract);\n              var file_path = file.file_path\n              single_page_pdf_file_paths.push(file.file_path);\n              self.emit('page', { hash: hash, text: extract, index: index, pdf_path: pdf_path});\n              cb();\n            });\n          },\n          function (err) {\n            if (!err) {\n              self.emit('complete', { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths});\n              return;\n            }\n            self.emit('error', { error: err, pdf_path: pdf_path});\n            if (!split_output || ! split_output.folder) { return }\n            fs.exists(split_output.folder, function (exists) {\n              if (!exists) { return }\n              var remove_cb = function() {}\n              rimraf(split_output.folder, remove_cb);\n            });\n          }\n        );\n      });\n    });\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}