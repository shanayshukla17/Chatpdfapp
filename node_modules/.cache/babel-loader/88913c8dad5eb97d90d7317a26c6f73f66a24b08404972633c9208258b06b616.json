{"ast":null,"code":"// main.js\n\nimport { isString } from 'bellajs';\nimport retrieve from './utils/retrieve.js';\nimport parseFromHtml from './utils/parseFromHtml.js';\nimport { getCharset } from './utils/html.js';\nimport { isValid as isValidUrl } from './utils/linker.js';\nexport const extract = async (input, parserOptions = {}, fetchOptions = {}) => {\n  if (!isString(input)) {\n    throw new Error('Input must be a string');\n  }\n  if (!isValidUrl(input)) {\n    return parseFromHtml(input, null, parserOptions || {});\n  }\n  const buffer = await retrieve(input, fetchOptions);\n  const text = buffer ? Buffer.from(buffer).toString().trim() : '';\n  if (!text) {\n    return null;\n  }\n  const charset = getCharset(text);\n  const decoder = new TextDecoder(charset);\n  const html = decoder.decode(buffer);\n  return parseFromHtml(html, input, parserOptions || {});\n};\nexport const extractFromHtml = async (html, url, parserOptions = {}) => {\n  return parseFromHtml(html, url, parserOptions);\n};\nexport { addTransformations, removeTransformations } from './utils/transformation.js';\nexport { setSanitizeHtmlOptions, getSanitizeHtmlOptions } from './config.js';","map":{"version":3,"names":["isString","retrieve","parseFromHtml","getCharset","isValid","isValidUrl","extract","input","parserOptions","fetchOptions","Error","buffer","text","Buffer","from","toString","trim","charset","decoder","TextDecoder","html","decode","extractFromHtml","url","addTransformations","removeTransformations","setSanitizeHtmlOptions","getSanitizeHtmlOptions"],"sources":["D:/LangChainJS/chatpdf/node_modules/@extractus/article-extractor/src/main.js"],"sourcesContent":["// main.js\n\nimport {\n  isString\n} from 'bellajs'\n\nimport retrieve from './utils/retrieve.js'\nimport parseFromHtml from './utils/parseFromHtml.js'\nimport { getCharset } from './utils/html.js'\nimport { isValid as isValidUrl } from './utils/linker.js'\n\nexport const extract = async (input, parserOptions = {}, fetchOptions = {}) => {\n  if (!isString(input)) {\n    throw new Error('Input must be a string')\n  }\n\n  if (!isValidUrl(input)) {\n    return parseFromHtml(input, null, parserOptions || {})\n  }\n  const buffer = await retrieve(input, fetchOptions)\n  const text = buffer ? Buffer.from(buffer).toString().trim() : ''\n  if (!text) {\n    return null\n  }\n  const charset = getCharset(text)\n  const decoder = new TextDecoder(charset)\n  const html = decoder.decode(buffer)\n  return parseFromHtml(html, input, parserOptions || {})\n}\n\nexport const extractFromHtml = async (html, url, parserOptions = {}) => {\n  return parseFromHtml(html, url, parserOptions)\n}\n\nexport { addTransformations, removeTransformations } from './utils/transformation.js'\nexport { setSanitizeHtmlOptions, getSanitizeHtmlOptions } from './config.js'\n"],"mappings":"AAAA;;AAEA,SACEA,QAAQ,QACH,SAAS;AAEhB,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAOC,aAAa,MAAM,0BAA0B;AACpD,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,OAAO,IAAIC,UAAU,QAAQ,mBAAmB;AAEzD,OAAO,MAAMC,OAAO,GAAG,MAAAA,CAAOC,KAAK,EAAEC,aAAa,GAAG,CAAC,CAAC,EAAEC,YAAY,GAAG,CAAC,CAAC,KAAK;EAC7E,IAAI,CAACT,QAAQ,CAACO,KAAK,CAAC,EAAE;IACpB,MAAM,IAAIG,KAAK,CAAC,wBAAwB,CAAC;EAC3C;EAEA,IAAI,CAACL,UAAU,CAACE,KAAK,CAAC,EAAE;IACtB,OAAOL,aAAa,CAACK,KAAK,EAAE,IAAI,EAAEC,aAAa,IAAI,CAAC,CAAC,CAAC;EACxD;EACA,MAAMG,MAAM,GAAG,MAAMV,QAAQ,CAACM,KAAK,EAAEE,YAAY,CAAC;EAClD,MAAMG,IAAI,GAAGD,MAAM,GAAGE,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAACI,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,GAAG,EAAE;EAChE,IAAI,CAACJ,IAAI,EAAE;IACT,OAAO,IAAI;EACb;EACA,MAAMK,OAAO,GAAGd,UAAU,CAACS,IAAI,CAAC;EAChC,MAAMM,OAAO,GAAG,IAAIC,WAAW,CAACF,OAAO,CAAC;EACxC,MAAMG,IAAI,GAAGF,OAAO,CAACG,MAAM,CAACV,MAAM,CAAC;EACnC,OAAOT,aAAa,CAACkB,IAAI,EAAEb,KAAK,EAAEC,aAAa,IAAI,CAAC,CAAC,CAAC;AACxD,CAAC;AAED,OAAO,MAAMc,eAAe,GAAG,MAAAA,CAAOF,IAAI,EAAEG,GAAG,EAAEf,aAAa,GAAG,CAAC,CAAC,KAAK;EACtE,OAAON,aAAa,CAACkB,IAAI,EAAEG,GAAG,EAAEf,aAAa,CAAC;AAChD,CAAC;AAED,SAASgB,kBAAkB,EAAEC,qBAAqB,QAAQ,2BAA2B;AACrF,SAASC,sBAAsB,EAAEC,sBAAsB,QAAQ,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}