{"ast":null,"code":"// source/lib.ts\n// The source code for the library.\nimport { Buffer } from 'node:buffer';\nimport { fileTypeFromBuffer as getFileType } from 'file-type';\nimport { readFile, fetchUrl } from './util.js';\n/**\n * The text extractor class.\n */\nexport class TextExtractor {\n  constructor() {\n    // The list of methods supported by this instance of the extractor.\n    this.methods = [];\n    /**\n     * Registers a new method to this instance of the extractor.\n     *\n     * @param method The method of text extraction to add.\n     * @returns The current instance, for method chaining.\n     */\n    this.addMethod = method => {\n      this.methods.push(method);\n      return this;\n    };\n    /**\n     * Extracts text from the given input.\n     *\n     * @param payload The input and type of input to extract text from.\n     * @returns The extracted text as a simple string.\n     */\n    this.extractText = async ({\n      input,\n      type\n    }) => {\n      // Turn the input into a buffer containing the file's contents.\n      let preparedInput;\n      if (typeof input === 'string') {\n        if (type === 'file') preparedInput = await readFile(input);else if (type === 'url') preparedInput = await fetchUrl(input);else preparedInput = Buffer.from(input);\n      } else {\n        preparedInput = input;\n      }\n      // Check the mime type of the file. If there is no mime type, it's most\n      // likely a txt/csv files.\n      const mimeDetails = await getFileType(preparedInput);\n      if (!mimeDetails) return preparedInput.toString();\n      // Find the extractor that can handle that mime type, and call it.\n      const extractor = this.methods.find(method => method.mimes.includes(mimeDetails.mime));\n      if (!extractor?.apply) {\n        const message = `text-extractor: could not find a method to handle ${mimeDetails.mime}`;\n        throw new Error(message);\n      }\n      return extractor.apply(preparedInput);\n    };\n  }\n}","map":{"version":3,"names":["Buffer","fileTypeFromBuffer","getFileType","readFile","fetchUrl","TextExtractor","constructor","methods","addMethod","method","push","extractText","input","type","preparedInput","from","mimeDetails","toString","extractor","find","mimes","includes","mime","apply","message","Error"],"sources":["D:/LangChainJS/chatpdf/node_modules/office-text-extractor/build/lib.js"],"sourcesContent":["// source/lib.ts\n// The source code for the library.\nimport { Buffer } from 'node:buffer';\nimport { fileTypeFromBuffer as getFileType } from 'file-type';\nimport { readFile, fetchUrl } from './util.js';\n/**\n * The text extractor class.\n */\nexport class TextExtractor {\n    constructor() {\n        // The list of methods supported by this instance of the extractor.\n        this.methods = [];\n        /**\n         * Registers a new method to this instance of the extractor.\n         *\n         * @param method The method of text extraction to add.\n         * @returns The current instance, for method chaining.\n         */\n        this.addMethod = (method) => {\n            this.methods.push(method);\n            return this;\n        };\n        /**\n         * Extracts text from the given input.\n         *\n         * @param payload The input and type of input to extract text from.\n         * @returns The extracted text as a simple string.\n         */\n        this.extractText = async ({ input, type }) => {\n            // Turn the input into a buffer containing the file's contents.\n            let preparedInput;\n            if (typeof input === 'string') {\n                if (type === 'file')\n                    preparedInput = await readFile(input);\n                else if (type === 'url')\n                    preparedInput = await fetchUrl(input);\n                else\n                    preparedInput = Buffer.from(input);\n            }\n            else {\n                preparedInput = input;\n            }\n            // Check the mime type of the file. If there is no mime type, it's most\n            // likely a txt/csv files.\n            const mimeDetails = await getFileType(preparedInput);\n            if (!mimeDetails)\n                return preparedInput.toString();\n            // Find the extractor that can handle that mime type, and call it.\n            const extractor = this.methods.find((method) => method.mimes.includes(mimeDetails.mime));\n            if (!extractor?.apply) {\n                const message = `text-extractor: could not find a method to handle ${mimeDetails.mime}`;\n                throw new Error(message);\n            }\n            return extractor.apply(preparedInput);\n        };\n    }\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,MAAM,QAAQ,aAAa;AACpC,SAASC,kBAAkB,IAAIC,WAAW,QAAQ,WAAW;AAC7D,SAASC,QAAQ,EAAEC,QAAQ,QAAQ,WAAW;AAC9C;AACA;AACA;AACA,OAAO,MAAMC,aAAa,CAAC;EACvBC,WAAWA,CAAA,EAAG;IACV;IACA,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAIC,MAAM,IAAK;MACzB,IAAI,CAACF,OAAO,CAACG,IAAI,CAACD,MAAM,CAAC;MACzB,OAAO,IAAI;IACf,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,WAAW,GAAG,OAAO;MAAEC,KAAK;MAAEC;IAAK,CAAC,KAAK;MAC1C;MACA,IAAIC,aAAa;MACjB,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;QAC3B,IAAIC,IAAI,KAAK,MAAM,EACfC,aAAa,GAAG,MAAMX,QAAQ,CAACS,KAAK,CAAC,CAAC,KACrC,IAAIC,IAAI,KAAK,KAAK,EACnBC,aAAa,GAAG,MAAMV,QAAQ,CAACQ,KAAK,CAAC,CAAC,KAEtCE,aAAa,GAAGd,MAAM,CAACe,IAAI,CAACH,KAAK,CAAC;MAC1C,CAAC,MACI;QACDE,aAAa,GAAGF,KAAK;MACzB;MACA;MACA;MACA,MAAMI,WAAW,GAAG,MAAMd,WAAW,CAACY,aAAa,CAAC;MACpD,IAAI,CAACE,WAAW,EACZ,OAAOF,aAAa,CAACG,QAAQ,CAAC,CAAC;MACnC;MACA,MAAMC,SAAS,GAAG,IAAI,CAACX,OAAO,CAACY,IAAI,CAAEV,MAAM,IAAKA,MAAM,CAACW,KAAK,CAACC,QAAQ,CAACL,WAAW,CAACM,IAAI,CAAC,CAAC;MACxF,IAAI,CAACJ,SAAS,EAAEK,KAAK,EAAE;QACnB,MAAMC,OAAO,GAAG,qDAAqDR,WAAW,CAACM,IAAI,EAAE;QACvF,MAAM,IAAIG,KAAK,CAACD,OAAO,CAAC;MAC5B;MACA,OAAON,SAAS,CAACK,KAAK,CAACT,aAAa,CAAC;IACzC,CAAC;EACL;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}