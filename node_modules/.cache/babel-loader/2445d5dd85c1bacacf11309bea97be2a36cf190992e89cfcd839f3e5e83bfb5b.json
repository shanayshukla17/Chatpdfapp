{"ast":null,"code":"/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar temp = require('temp');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\n\n/**\n * @param tif_path path to the single page file on disk containing a scanned image of text\n * @param {Array} options is an optional list of flags to pass to the tesseract command\n * @return {String} extract the extracted ocr text output\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function (input_path, options, callback) {\n  // options is an optional parameter\n  if (!callback || typeof callback != \"function\") {\n    // callback must be the second parameter\n    callback = options;\n    options = [];\n  }\n  fs.exists(input_path, function (exists) {\n    if (!exists) {\n      return callback('error, no file exists at the path you specified: ' + input_path);\n    }\n    // get a temp output path\n    var output_path = temp.path({\n      prefix: 'ocr_output'\n    });\n    // output_path = path.join(__dirname,'test/test_data/single_page_raw');\n    var cmd = 'tesseract \"' + input_path + '\" \"' + output_path + '\" ' + options.join(' ');\n    var child = exec(cmd, function (err, stdout, stderr) {\n      if (err) {\n        return callback(err);\n      }\n      // tesseract automatically appends \".txt\" to the output file name\n      var text_output_path = output_path + '.txt';\n      // inspect(text_output_path, 'text output path');\n      fs.readFile(text_output_path, 'utf8', function (err, output) {\n        // inspect(output, 'ocr output');\n        if (err) {\n          return callback(err);\n        }\n        // cleanup after ourselves\n        fs.unlink(text_output_path, function (err) {\n          if (err) {\n            return callback(err);\n          }\n          callback(null, output);\n        });\n      });\n    });\n  });\n};","map":{"version":3,"names":["temp","require","path","exec","fs","module","exports","input_path","options","callback","exists","output_path","prefix","cmd","join","child","err","stdout","stderr","text_output_path","readFile","output","unlink"],"sources":["D:/LangChainJS/chatpdf/node_modules/pdf-extract/lib/ocr.js"],"sourcesContent":["/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar temp = require('temp');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\n\n/**\n * @param tif_path path to the single page file on disk containing a scanned image of text\n * @param {Array} options is an optional list of flags to pass to the tesseract command\n * @return {String} extract the extracted ocr text output\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function(input_path, options, callback) {\n  // options is an optional parameter\n  if (!callback || typeof callback != \"function\") {\n    // callback must be the second parameter\n    callback = options;\n    options = [];\n  }\n  fs.exists(input_path, function (exists) {\n    if (!exists) { return callback('error, no file exists at the path you specified: ' + input_path); }\n    // get a temp output path\n    var output_path = temp.path({prefix: 'ocr_output'});\n    // output_path = path.join(__dirname,'test/test_data/single_page_raw');\n    var cmd = 'tesseract \"'+input_path+'\" \"'+output_path+'\" '+options.join(' ');\n    var child = exec(cmd, function (err, stdout, stderr) {\n      if (err) { return callback(err); }\n      // tesseract automatically appends \".txt\" to the output file name\n      var text_output_path = output_path+'.txt';\n      // inspect(text_output_path, 'text output path');\n      fs.readFile(text_output_path, 'utf8', function(err, output) {\n        // inspect(output, 'ocr output');\n        if (err) { return callback(err); }\n        // cleanup after ourselves\n        fs.unlink(text_output_path, function (err) {\n          if (err) { return callback(err); }\n          callback(null, output);\n        });\n      });\n    });\n  });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIE,IAAI,GAAGF,OAAO,CAAC,eAAe,CAAC,CAACE,IAAI;AACxC,IAAIC,EAAE,GAAGH,OAAO,CAAC,IAAI,CAAC;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACAI,MAAM,CAACC,OAAO,GAAG,UAASC,UAAU,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EACvD;EACA,IAAI,CAACA,QAAQ,IAAI,OAAOA,QAAQ,IAAI,UAAU,EAAE;IAC9C;IACAA,QAAQ,GAAGD,OAAO;IAClBA,OAAO,GAAG,EAAE;EACd;EACAJ,EAAE,CAACM,MAAM,CAACH,UAAU,EAAE,UAAUG,MAAM,EAAE;IACtC,IAAI,CAACA,MAAM,EAAE;MAAE,OAAOD,QAAQ,CAAC,mDAAmD,GAAGF,UAAU,CAAC;IAAE;IAClG;IACA,IAAII,WAAW,GAAGX,IAAI,CAACE,IAAI,CAAC;MAACU,MAAM,EAAE;IAAY,CAAC,CAAC;IACnD;IACA,IAAIC,GAAG,GAAG,aAAa,GAACN,UAAU,GAAC,KAAK,GAACI,WAAW,GAAC,IAAI,GAACH,OAAO,CAACM,IAAI,CAAC,GAAG,CAAC;IAC3E,IAAIC,KAAK,GAAGZ,IAAI,CAACU,GAAG,EAAE,UAAUG,GAAG,EAAEC,MAAM,EAAEC,MAAM,EAAE;MACnD,IAAIF,GAAG,EAAE;QAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;MAAE;MACjC;MACA,IAAIG,gBAAgB,GAAGR,WAAW,GAAC,MAAM;MACzC;MACAP,EAAE,CAACgB,QAAQ,CAACD,gBAAgB,EAAE,MAAM,EAAE,UAASH,GAAG,EAAEK,MAAM,EAAE;QAC1D;QACA,IAAIL,GAAG,EAAE;UAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;QAAE;QACjC;QACAZ,EAAE,CAACkB,MAAM,CAACH,gBAAgB,EAAE,UAAUH,GAAG,EAAE;UACzC,IAAIA,GAAG,EAAE;YAAE,OAAOP,QAAQ,CAACO,GAAG,CAAC;UAAE;UACjCP,QAAQ,CAAC,IAAI,EAAEY,MAAM,CAAC;QACxB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}