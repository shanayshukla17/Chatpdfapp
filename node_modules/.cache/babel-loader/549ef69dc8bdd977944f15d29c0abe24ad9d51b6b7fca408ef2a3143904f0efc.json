{"ast":null,"code":"/**\n * Module which splits multi-pag pdfs into single pages\n * Requires the pdftk binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @see get_pdfs_in_directory\n * @return {Object} an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output_paths)\n */\nmodule.exports = function (pdf_path, callback) {\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    var output_dir = temp.path({}, 'pdf_pages');\n    fs.mkdir(output_dir, function (err) {\n      if (err) {\n        return callback(err, null);\n      }\n      // name the files with the upload id and a digit string\n      // example: \"507c3e55c786e2aa6f000005-page00001.pdf\"\n      var output_name = 'page%05d.pdf\"';\n      var output_path = path.join(output_dir, output_name);\n      var cmd = 'pdftk \"' + pdf_path + '\" burst output \"' + output_path;\n      var child = exec(cmd, function (err, stdout, stderr) {\n        if (err) {\n          var output_err = {\n            message: 'an error occurred while splitting pdf into single pages with the pdftk burst command',\n            error: err\n          };\n          callback(output_err, null);\n          return;\n        }\n        remove_doc_data(function (err, reply) {\n          if (err) {\n            return callback(err);\n          }\n          return get_pdfs_in_directory(output_dir, callback);\n        });\n      });\n    });\n  });\n};\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Object} output an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, {\n    followLinks: false\n  });\n  walker.on('file', function (root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({\n        file_path: file_path,\n        file_name: stat.name\n      });\n    }\n    next();\n  });\n  walker.on('end', function () {\n    file_paths.sort(function (a, b) {\n      if (a.file_name < b.file_name) {\n        return -1;\n      }\n      if (a.file_name == b.file_name) {\n        return 0;\n      }\n      return 1;\n    });\n    var output = {\n      folder: directory_path,\n      files: file_paths\n    };\n    return callback(null, output);\n  });\n}\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n}\n;\n\n/**\n * pdftk creates a file called doc_data.txt during the burst split process.\n * This file is not needed so remove it now\n */\nfunction remove_doc_data(callback) {\n  var folder = path.join(__dirname, '..');\n  var doc_data_path = path.join(folder, 'doc_data.txt');\n  fs.exists(doc_data_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    fs.unlink(doc_data_path, callback);\n  });\n}","map":{"version":3,"names":["path","require","temp","exec","fs","walk","async","rimraf","module","exports","pdf_path","callback","confirm_file_exists","err","output_dir","mkdir","output_name","output_path","join","cmd","child","stdout","stderr","output_err","message","error","remove_doc_data","reply","get_pdfs_in_directory","directory_path","file_paths","files","walker","followLinks","on","root","stat","next","name","match","file_path","push","file_name","sort","a","b","output","folder","exists","__dirname","doc_data_path","unlink"],"sources":["D:/LangChainJS/chatpdf/node_modules/pdf-extract/lib/split.js"],"sourcesContent":["/**\n * Module which splits multi-pag pdfs into single pages\n * Requires the pdftk binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @see get_pdfs_in_directory\n * @return {Object} an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output_paths)\n */\nmodule.exports = function(pdf_path, callback) {\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) { return callback(err); }\n\n    var output_dir = temp.path({},'pdf_pages');\n    fs.mkdir(output_dir, function(err) {\n      if (err) { return callback(err, null); }\n      // name the files with the upload id and a digit string\n      // example: \"507c3e55c786e2aa6f000005-page00001.pdf\"\n      var output_name = 'page%05d.pdf\"';\n      var output_path = path.join(output_dir, output_name);\n      var cmd = 'pdftk \"'+pdf_path+'\" burst output \"'+ output_path;\n      var child = exec(cmd, function (err, stdout, stderr) {\n        if (err) {\n          var output_err = {\n            message: 'an error occurred while splitting pdf into single pages with the pdftk burst command',\n            error: err\n          }\n          callback(output_err, null);\n          return;\n        }\n        remove_doc_data(function (err, reply) {\n          if (err) { return callback(err); }\n          return get_pdfs_in_directory(output_dir, callback);\n        });\n      });\n    });\n  });\n}\n\n\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Object} output an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, { followLinks: false});\n  walker.on('file', function(root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({file_path: file_path, file_name: stat.name});\n    }\n    next();\n  });\n\n\n  walker.on('end', function() {\n    file_paths.sort(function (a,b) {\n      if (a.file_name < b.file_name) {\n        return -1;\n      }\n      if (a.file_name == b.file_name) {\n        return 0;\n      }\n      return 1;\n    });\n    var output = {\n      folder: directory_path,\n      files: file_paths\n    }\n    return callback(null, output);\n  });\n}\n\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n};\n\n/**\n * pdftk creates a file called doc_data.txt during the burst split process.\n * This file is not needed so remove it now\n */\nfunction remove_doc_data(callback) {\n  var folder = path.join(__dirname, '..');\n  var doc_data_path = path.join(folder, 'doc_data.txt');\n  fs.exists(doc_data_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    fs.unlink(doc_data_path, callback);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}